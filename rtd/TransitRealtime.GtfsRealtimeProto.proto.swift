// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source file gtfs-realtime.proto.txt

import Foundation
import ProtocolBuffers




public func == (lhs: TransitRealtime.FeedMessage, rhs: TransitRealtime.FeedMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasHeader == rhs.hasHeader) && (!lhs.hasHeader || lhs.header == rhs.header)
  fieldCheck = fieldCheck && (lhs.entity == rhs.entity)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(2000))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: TransitRealtime.FeedHeader, rhs: TransitRealtime.FeedHeader) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasGtfsRealtimeVersion == rhs.hasGtfsRealtimeVersion) && (!lhs.hasGtfsRealtimeVersion || lhs.gtfsRealtimeVersion == rhs.gtfsRealtimeVersion)
  fieldCheck = fieldCheck && (lhs.hasIncrementality == rhs.hasIncrementality) && (!lhs.hasIncrementality || lhs.incrementality == rhs.incrementality)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(2000))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: TransitRealtime.FeedEntity, rhs: TransitRealtime.FeedEntity) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasIsDeleted == rhs.hasIsDeleted) && (!lhs.hasIsDeleted || lhs.isDeleted == rhs.isDeleted)
  fieldCheck = fieldCheck && (lhs.hasTripUpdate == rhs.hasTripUpdate) && (!lhs.hasTripUpdate || lhs.tripUpdate == rhs.tripUpdate)
  fieldCheck = fieldCheck && (lhs.hasVehicle == rhs.hasVehicle) && (!lhs.hasVehicle || lhs.vehicle == rhs.vehicle)
  fieldCheck = fieldCheck && (lhs.hasAlert == rhs.hasAlert) && (!lhs.hasAlert || lhs.alert == rhs.alert)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(2000))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: TransitRealtime.TripUpdate, rhs: TransitRealtime.TripUpdate) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTrip == rhs.hasTrip) && (!lhs.hasTrip || lhs.trip == rhs.trip)
  fieldCheck = fieldCheck && (lhs.stopTimeUpdate == rhs.stopTimeUpdate)
  fieldCheck = fieldCheck && (lhs.hasVehicle == rhs.hasVehicle) && (!lhs.hasVehicle || lhs.vehicle == rhs.vehicle)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = fieldCheck && (lhs.hasDelay == rhs.hasDelay) && (!lhs.hasDelay || lhs.delay == rhs.delay)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(2000))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: TransitRealtime.TripUpdate.StopTimeEvent, rhs: TransitRealtime.TripUpdate.StopTimeEvent) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDelay == rhs.hasDelay) && (!lhs.hasDelay || lhs.delay == rhs.delay)
  fieldCheck = fieldCheck && (lhs.hasTime == rhs.hasTime) && (!lhs.hasTime || lhs.time == rhs.time)
  fieldCheck = fieldCheck && (lhs.hasUncertainty == rhs.hasUncertainty) && (!lhs.hasUncertainty || lhs.uncertainty == rhs.uncertainty)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(2000))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: TransitRealtime.TripUpdate.StopTimeUpdate, rhs: TransitRealtime.TripUpdate.StopTimeUpdate) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStopSequence == rhs.hasStopSequence) && (!lhs.hasStopSequence || lhs.stopSequence == rhs.stopSequence)
  fieldCheck = fieldCheck && (lhs.hasArrival == rhs.hasArrival) && (!lhs.hasArrival || lhs.arrival == rhs.arrival)
  fieldCheck = fieldCheck && (lhs.hasDeparture == rhs.hasDeparture) && (!lhs.hasDeparture || lhs.departure == rhs.departure)
  fieldCheck = fieldCheck && (lhs.hasStopId == rhs.hasStopId) && (!lhs.hasStopId || lhs.stopId == rhs.stopId)
  fieldCheck = fieldCheck && (lhs.hasScheduleRelationship == rhs.hasScheduleRelationship) && (!lhs.hasScheduleRelationship || lhs.scheduleRelationship == rhs.scheduleRelationship)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(2000))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: TransitRealtime.VehiclePosition, rhs: TransitRealtime.VehiclePosition) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTrip == rhs.hasTrip) && (!lhs.hasTrip || lhs.trip == rhs.trip)
  fieldCheck = fieldCheck && (lhs.hasPosition == rhs.hasPosition) && (!lhs.hasPosition || lhs.position == rhs.position)
  fieldCheck = fieldCheck && (lhs.hasCurrentStopSequence == rhs.hasCurrentStopSequence) && (!lhs.hasCurrentStopSequence || lhs.currentStopSequence == rhs.currentStopSequence)
  fieldCheck = fieldCheck && (lhs.hasCurrentStatus == rhs.hasCurrentStatus) && (!lhs.hasCurrentStatus || lhs.currentStatus == rhs.currentStatus)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = fieldCheck && (lhs.hasCongestionLevel == rhs.hasCongestionLevel) && (!lhs.hasCongestionLevel || lhs.congestionLevel == rhs.congestionLevel)
  fieldCheck = fieldCheck && (lhs.hasStopId == rhs.hasStopId) && (!lhs.hasStopId || lhs.stopId == rhs.stopId)
  fieldCheck = fieldCheck && (lhs.hasVehicle == rhs.hasVehicle) && (!lhs.hasVehicle || lhs.vehicle == rhs.vehicle)
  fieldCheck = fieldCheck && (lhs.hasOccupancyStatus == rhs.hasOccupancyStatus) && (!lhs.hasOccupancyStatus || lhs.occupancyStatus == rhs.occupancyStatus)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(2000))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: TransitRealtime.Alert, rhs: TransitRealtime.Alert) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.activePeriod == rhs.activePeriod)
  fieldCheck = fieldCheck && (lhs.informedEntity == rhs.informedEntity)
  fieldCheck = fieldCheck && (lhs.hasCause == rhs.hasCause) && (!lhs.hasCause || lhs.cause == rhs.cause)
  fieldCheck = fieldCheck && (lhs.hasEffect == rhs.hasEffect) && (!lhs.hasEffect || lhs.effect == rhs.effect)
  fieldCheck = fieldCheck && (lhs.hasUrl == rhs.hasUrl) && (!lhs.hasUrl || lhs.url == rhs.url)
  fieldCheck = fieldCheck && (lhs.hasHeaderText == rhs.hasHeaderText) && (!lhs.hasHeaderText || lhs.headerText == rhs.headerText)
  fieldCheck = fieldCheck && (lhs.hasDescriptionText == rhs.hasDescriptionText) && (!lhs.hasDescriptionText || lhs.descriptionText == rhs.descriptionText)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(2000))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: TransitRealtime.TimeRange, rhs: TransitRealtime.TimeRange) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStart == rhs.hasStart) && (!lhs.hasStart || lhs.start == rhs.start)
  fieldCheck = fieldCheck && (lhs.hasEnd == rhs.hasEnd) && (!lhs.hasEnd || lhs.end == rhs.end)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(2000))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: TransitRealtime.Position, rhs: TransitRealtime.Position) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  fieldCheck = fieldCheck && (lhs.hasBearing == rhs.hasBearing) && (!lhs.hasBearing || lhs.bearing == rhs.bearing)
  fieldCheck = fieldCheck && (lhs.hasOdometer == rhs.hasOdometer) && (!lhs.hasOdometer || lhs.odometer == rhs.odometer)
  fieldCheck = fieldCheck && (lhs.hasSpeed == rhs.hasSpeed) && (!lhs.hasSpeed || lhs.speed == rhs.speed)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(2000))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: TransitRealtime.TripDescriptor, rhs: TransitRealtime.TripDescriptor) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTripId == rhs.hasTripId) && (!lhs.hasTripId || lhs.tripId == rhs.tripId)
  fieldCheck = fieldCheck && (lhs.hasStartTime == rhs.hasStartTime) && (!lhs.hasStartTime || lhs.startTime == rhs.startTime)
  fieldCheck = fieldCheck && (lhs.hasStartDate == rhs.hasStartDate) && (!lhs.hasStartDate || lhs.startDate == rhs.startDate)
  fieldCheck = fieldCheck && (lhs.hasScheduleRelationship == rhs.hasScheduleRelationship) && (!lhs.hasScheduleRelationship || lhs.scheduleRelationship == rhs.scheduleRelationship)
  fieldCheck = fieldCheck && (lhs.hasRouteId == rhs.hasRouteId) && (!lhs.hasRouteId || lhs.routeId == rhs.routeId)
  fieldCheck = fieldCheck && (lhs.hasDirectionId == rhs.hasDirectionId) && (!lhs.hasDirectionId || lhs.directionId == rhs.directionId)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(2000))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: TransitRealtime.VehicleDescriptor, rhs: TransitRealtime.VehicleDescriptor) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasLabel == rhs.hasLabel) && (!lhs.hasLabel || lhs.label == rhs.label)
  fieldCheck = fieldCheck && (lhs.hasLicensePlate == rhs.hasLicensePlate) && (!lhs.hasLicensePlate || lhs.licensePlate == rhs.licensePlate)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(2000))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: TransitRealtime.EntitySelector, rhs: TransitRealtime.EntitySelector) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasAgencyId == rhs.hasAgencyId) && (!lhs.hasAgencyId || lhs.agencyId == rhs.agencyId)
  fieldCheck = fieldCheck && (lhs.hasRouteId == rhs.hasRouteId) && (!lhs.hasRouteId || lhs.routeId == rhs.routeId)
  fieldCheck = fieldCheck && (lhs.hasRouteType == rhs.hasRouteType) && (!lhs.hasRouteType || lhs.routeType == rhs.routeType)
  fieldCheck = fieldCheck && (lhs.hasTrip == rhs.hasTrip) && (!lhs.hasTrip || lhs.trip == rhs.trip)
  fieldCheck = fieldCheck && (lhs.hasStopId == rhs.hasStopId) && (!lhs.hasStopId || lhs.stopId == rhs.stopId)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(2000))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: TransitRealtime.TranslatedString, rhs: TransitRealtime.TranslatedString) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.translation == rhs.translation)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(2000))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: TransitRealtime.TranslatedString.Translation, rhs: TransitRealtime.TranslatedString.Translation) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasText == rhs.hasText) && (!lhs.hasText || lhs.text == rhs.text)
  fieldCheck = fieldCheck && (lhs.hasLanguage == rhs.hasLanguage) && (!lhs.hasLanguage || lhs.language == rhs.language)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(2000))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public struct TransitRealtime {
  public struct GtfsRealtimeProtoTxtRoot {
    public static var sharedInstance : GtfsRealtimeProtoTxtRoot {
     struct Static {
         static let instance : GtfsRealtimeProtoTxtRoot = GtfsRealtimeProtoTxtRoot()
     }
     return Static.instance
    }
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(extensionRegistry)
    }
    public func registerAllExtensions(registry:ExtensionRegistry) {
    }
  }

  // The contents of a feed message.
  // A feed is a continuous stream of feed messages. Each message in the stream is
  // obtained as a response to an appropriate HTTP GET request.
  // A realtime feed is always defined with relation to an existing GTFS feed.
  // All the entity ids are resolved with respect to the GTFS feed.
  // A feed depends on some external configuration:
  // - The corresponding GTFS feed.
  // - Feed application (updates, positions or alerts). A feed should contain only
  //   items of one specified application; all the other entities will be ignored.
  // - Polling frequency
  final public class FeedMessage : ExtendableMessage, GeneratedMessageProtocol{
    public private(set) var header:TransitRealtime.FeedHeader!
    public private(set) var hasHeader:Bool = false
    public private(set) var entity:Array<TransitRealtime.FeedEntity>  = Array<TransitRealtime.FeedEntity>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !hasHeader {
        return false
      }
      if !header.isInitialized() {
        return false
      }
      var isInitentity:Bool = true
      for oneElemententity in entity {
          if (!oneElemententity.isInitialized()) {
              isInitentity = false
              break 
          }
      }
      if !isInitentity {
       return isInitentity
       }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasHeader {
        try output.writeMessage(1, value:header)
      }
      for oneElemententity in entity {
          try output.writeMessage(2, value:oneElemententity)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(2000))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasHeader {
          if let varSizeheader = header?.computeMessageSize(1) {
              serialize_size += varSizeheader
          }
      }
      for oneElemententity in entity {
          serialize_size += oneElemententity.computeMessageSize(2)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TransitRealtime.FeedMessage> {
      var mergedArray = Array<TransitRealtime.FeedMessage>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TransitRealtime.FeedMessage? {
      return try TransitRealtime.FeedMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> TransitRealtime.FeedMessage {
      return try TransitRealtime.FeedMessage.Builder().mergeFromData(data, extensionRegistry:TransitRealtime.GtfsRealtimeProtoTxtRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedMessage {
      return try TransitRealtime.FeedMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> TransitRealtime.FeedMessage {
      return try TransitRealtime.FeedMessage.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedMessage {
      return try TransitRealtime.FeedMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.FeedMessage {
      return try TransitRealtime.FeedMessage.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedMessage {
      return try TransitRealtime.FeedMessage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> TransitRealtime.FeedMessage.Builder {
      return TransitRealtime.FeedMessage.classBuilder() as! TransitRealtime.FeedMessage.Builder
    }
    public func getBuilder() -> TransitRealtime.FeedMessage.Builder {
      return classBuilder() as! TransitRealtime.FeedMessage.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return TransitRealtime.FeedMessage.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return TransitRealtime.FeedMessage.Builder()
    }
    public func toBuilder() throws -> TransitRealtime.FeedMessage.Builder {
      return try TransitRealtime.FeedMessage.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:TransitRealtime.FeedMessage) throws -> TransitRealtime.FeedMessage.Builder {
      return try TransitRealtime.FeedMessage.Builder().mergeFrom(prototype)
    }
    override public func getDescription(indent:String) throws -> String {
      var output:String = ""
      if hasHeader {
        output += "\(indent) header {\n"
        if let outDescHeader = header {
          output += try outDescHeader.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      var entityElementIndex:Int = 0
      for oneElemententity in entity {
          output += "\(indent) entity[\(entityElementIndex)] {\n"
          output += try oneElemententity.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          entityElementIndex += 1
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(2000), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasHeader {
                if let hashValueheader = header?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueheader
                }
            }
            for oneElemententity in entity {
                hashCode = (hashCode &* 31) &+ oneElemententity.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(2000)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "TransitRealtime.FeedMessage"
    }
    override public func className() -> String {
        return "TransitRealtime.FeedMessage"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return TransitRealtime.FeedMessage.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:TransitRealtime.FeedMessage = TransitRealtime.FeedMessage()
      public func getMessage() -> TransitRealtime.FeedMessage {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasHeader:Bool {
           get {
               return builderResult.hasHeader
           }
      }
      public var header:TransitRealtime.FeedHeader! {
           get {
               if headerBuilder_ != nil {
                  builderResult.header = headerBuilder_.getMessage()
               }
               return builderResult.header
           }
           set (value) {
               builderResult.hasHeader = true
               builderResult.header = value
           }
      }
      private var headerBuilder_:TransitRealtime.FeedHeader.Builder! {
           didSet {
              builderResult.hasHeader = true
           }
      }
      public func getHeaderBuilder() -> TransitRealtime.FeedHeader.Builder {
        if headerBuilder_ == nil {
           headerBuilder_ = TransitRealtime.FeedHeader.Builder()
           builderResult.header = headerBuilder_.getMessage()
           if header != nil {
              try! headerBuilder_.mergeFrom(header)
           }
        }
        return headerBuilder_
      }
      public func setHeader(value:TransitRealtime.FeedHeader!) -> TransitRealtime.FeedMessage.Builder {
        self.header = value
        return self
      }
      public func mergeHeader(value:TransitRealtime.FeedHeader) throws -> TransitRealtime.FeedMessage.Builder {
        if builderResult.hasHeader {
          builderResult.header = try TransitRealtime.FeedHeader.builderWithPrototype(builderResult.header).mergeFrom(value).buildPartial()
        } else {
          builderResult.header = value
        }
        builderResult.hasHeader = true
        return self
      }
      public func clearHeader() -> TransitRealtime.FeedMessage.Builder {
        headerBuilder_ = nil
        builderResult.hasHeader = false
        builderResult.header = nil
        return self
      }
      public var entity:Array<TransitRealtime.FeedEntity> {
           get {
               return builderResult.entity
           }
           set (value) {
               builderResult.entity = value
           }
      }
      public func setEntity(value:Array<TransitRealtime.FeedEntity>) -> TransitRealtime.FeedMessage.Builder {
        self.entity = value
        return self
      }
      public func clearEntity() -> TransitRealtime.FeedMessage.Builder {
        builderResult.entity.removeAll(keepCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> TransitRealtime.FeedMessage.Builder {
        builderResult = TransitRealtime.FeedMessage()
        return self
      }
      public override func clone() throws -> TransitRealtime.FeedMessage.Builder {
        return try TransitRealtime.FeedMessage.builderWithPrototype(builderResult)
      }
      public override func build() throws -> TransitRealtime.FeedMessage {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> TransitRealtime.FeedMessage {
        let returnMe:TransitRealtime.FeedMessage = builderResult
        return returnMe
      }
      public func mergeFrom(other:TransitRealtime.FeedMessage) throws -> TransitRealtime.FeedMessage.Builder {
        if other == TransitRealtime.FeedMessage() {
         return self
        }
        if (other.hasHeader) {
            try mergeHeader(other.header)
        }
        if !other.entity.isEmpty  {
           builderResult.entity += other.entity
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.FeedMessage.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedMessage.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            let subBuilder:TransitRealtime.FeedHeader.Builder = TransitRealtime.FeedHeader.Builder()
            if hasHeader {
              try subBuilder.mergeFrom(header)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            header = subBuilder.buildPartial()

          case 18 :
            let subBuilder = TransitRealtime.FeedEntity.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            entity += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  // Metadata about a feed, included in feed messages.
  final public class FeedHeader : ExtendableMessage, GeneratedMessageProtocol{


      //Enum type declaration start 

      // Determines whether the current fetch is incremental.  Currently,
      // DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
      // that use this mode.  There are discussions on the GTFS-realtime mailing
      // list around fully specifying the behavior of DIFFERENTIAL mode and the
      // documentation will be updated when those discussions are finalized.
      public enum Incrementality:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case FullDataset = 0
        case Differential = 1

        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .FullDataset: return ".FullDataset"
                case .Differential: return ".Differential"
            }
        }
      }

      //Enum type declaration end 

    // Version of the feed specification.
    // The current version is 1.0.
    public private(set) var gtfsRealtimeVersion:String = ""

    public private(set) var hasGtfsRealtimeVersion:Bool = false
    public private(set) var incrementality:TransitRealtime.FeedHeader.Incrementality = TransitRealtime.FeedHeader.Incrementality.FullDataset
    public private(set) var hasIncrementality:Bool = false
    // This timestamp identifies the moment when the content of this feed has been
    // created (in server time). In POSIX time (i.e., number of seconds since
    // January 1st 1970 00:00:00 UTC).
    public private(set) var timestamp:UInt64 = UInt64(0)

    public private(set) var hasTimestamp:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !hasGtfsRealtimeVersion {
        return false
      }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasGtfsRealtimeVersion {
        try output.writeString(1, value:gtfsRealtimeVersion)
      }
      if hasIncrementality {
        try output.writeEnum(2, value:incrementality.rawValue)
      }
      if hasTimestamp {
        try output.writeUInt64(3, value:timestamp)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(2000))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasGtfsRealtimeVersion {
        serialize_size += gtfsRealtimeVersion.computeStringSize(1)
      }
      if (hasIncrementality) {
        serialize_size += incrementality.rawValue.computeEnumSize(2)
      }
      if hasTimestamp {
        serialize_size += timestamp.computeUInt64Size(3)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TransitRealtime.FeedHeader> {
      var mergedArray = Array<TransitRealtime.FeedHeader>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TransitRealtime.FeedHeader? {
      return try TransitRealtime.FeedHeader.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> TransitRealtime.FeedHeader {
      return try TransitRealtime.FeedHeader.Builder().mergeFromData(data, extensionRegistry:TransitRealtime.GtfsRealtimeProtoTxtRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedHeader {
      return try TransitRealtime.FeedHeader.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> TransitRealtime.FeedHeader {
      return try TransitRealtime.FeedHeader.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedHeader {
      return try TransitRealtime.FeedHeader.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.FeedHeader {
      return try TransitRealtime.FeedHeader.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedHeader {
      return try TransitRealtime.FeedHeader.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> TransitRealtime.FeedHeader.Builder {
      return TransitRealtime.FeedHeader.classBuilder() as! TransitRealtime.FeedHeader.Builder
    }
    public func getBuilder() -> TransitRealtime.FeedHeader.Builder {
      return classBuilder() as! TransitRealtime.FeedHeader.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return TransitRealtime.FeedHeader.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return TransitRealtime.FeedHeader.Builder()
    }
    public func toBuilder() throws -> TransitRealtime.FeedHeader.Builder {
      return try TransitRealtime.FeedHeader.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:TransitRealtime.FeedHeader) throws -> TransitRealtime.FeedHeader.Builder {
      return try TransitRealtime.FeedHeader.Builder().mergeFrom(prototype)
    }
    override public func getDescription(indent:String) throws -> String {
      var output:String = ""
      if hasGtfsRealtimeVersion {
        output += "\(indent) gtfsRealtimeVersion: \(gtfsRealtimeVersion) \n"
      }
      if (hasIncrementality) {
        output += "\(indent) incrementality: \(incrementality.description)\n"
      }
      if hasTimestamp {
        output += "\(indent) timestamp: \(timestamp) \n"
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(2000), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasGtfsRealtimeVersion {
               hashCode = (hashCode &* 31) &+ gtfsRealtimeVersion.hashValue
            }
            if hasIncrementality {
               hashCode = (hashCode &* 31) &+ Int(incrementality.rawValue)
            }
            if hasTimestamp {
               hashCode = (hashCode &* 31) &+ timestamp.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(2000)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "TransitRealtime.FeedHeader"
    }
    override public func className() -> String {
        return "TransitRealtime.FeedHeader"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return TransitRealtime.FeedHeader.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:TransitRealtime.FeedHeader = TransitRealtime.FeedHeader()
      public func getMessage() -> TransitRealtime.FeedHeader {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasGtfsRealtimeVersion:Bool {
           get {
                return builderResult.hasGtfsRealtimeVersion
           }
      }
      public var gtfsRealtimeVersion:String {
           get {
                return builderResult.gtfsRealtimeVersion
           }
           set (value) {
               builderResult.hasGtfsRealtimeVersion = true
               builderResult.gtfsRealtimeVersion = value
           }
      }
      public func setGtfsRealtimeVersion(value:String) -> TransitRealtime.FeedHeader.Builder {
        self.gtfsRealtimeVersion = value
        return self
      }
      public func clearGtfsRealtimeVersion() -> TransitRealtime.FeedHeader.Builder{
           builderResult.hasGtfsRealtimeVersion = false
           builderResult.gtfsRealtimeVersion = ""
           return self
      }
        public var hasIncrementality:Bool{
            get {
                return builderResult.hasIncrementality
            }
        }
        public var incrementality:TransitRealtime.FeedHeader.Incrementality {
            get {
                return builderResult.incrementality
            }
            set (value) {
                builderResult.hasIncrementality = true
                builderResult.incrementality = value
            }
        }
        public func setIncrementality(value:TransitRealtime.FeedHeader.Incrementality) -> TransitRealtime.FeedHeader.Builder {
          self.incrementality = value
          return self
        }
        public func clearIncrementality() -> TransitRealtime.FeedHeader.Builder {
           builderResult.hasIncrementality = false
           builderResult.incrementality = .FullDataset
           return self
        }
      public var hasTimestamp:Bool {
           get {
                return builderResult.hasTimestamp
           }
      }
      public var timestamp:UInt64 {
           get {
                return builderResult.timestamp
           }
           set (value) {
               builderResult.hasTimestamp = true
               builderResult.timestamp = value
           }
      }
      public func setTimestamp(value:UInt64) -> TransitRealtime.FeedHeader.Builder {
        self.timestamp = value
        return self
      }
      public func clearTimestamp() -> TransitRealtime.FeedHeader.Builder{
           builderResult.hasTimestamp = false
           builderResult.timestamp = UInt64(0)
           return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> TransitRealtime.FeedHeader.Builder {
        builderResult = TransitRealtime.FeedHeader()
        return self
      }
      public override func clone() throws -> TransitRealtime.FeedHeader.Builder {
        return try TransitRealtime.FeedHeader.builderWithPrototype(builderResult)
      }
      public override func build() throws -> TransitRealtime.FeedHeader {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> TransitRealtime.FeedHeader {
        let returnMe:TransitRealtime.FeedHeader = builderResult
        return returnMe
      }
      public func mergeFrom(other:TransitRealtime.FeedHeader) throws -> TransitRealtime.FeedHeader.Builder {
        if other == TransitRealtime.FeedHeader() {
         return self
        }
        if other.hasGtfsRealtimeVersion {
             gtfsRealtimeVersion = other.gtfsRealtimeVersion
        }
        if other.hasIncrementality {
             incrementality = other.incrementality
        }
        if other.hasTimestamp {
             timestamp = other.timestamp
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.FeedHeader.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedHeader.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            gtfsRealtimeVersion = try input.readString()

          case 16 :
            let valueIntincrementality = try input.readEnum()
            if let enumsincrementality = TransitRealtime.FeedHeader.Incrementality(rawValue:valueIntincrementality){
                 incrementality = enumsincrementality
            } else {
                 try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntincrementality))
            }

          case 24 :
            timestamp = try input.readUInt64()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  // A definition (or update) of an entity in the transit feed.
  final public class FeedEntity : ExtendableMessage, GeneratedMessageProtocol{
    // The ids are used only to provide incrementality support. The id should be
    // unique within a FeedMessage. Consequent FeedMessages may contain
    // FeedEntities with the same id. In case of a DIFFERENTIAL update the new
    // FeedEntity with some id will replace the old FeedEntity with the same id
    // (or delete it - see is_deleted below).
    // The actual GTFS entities (e.g. stations, routes, trips) referenced by the
    // feed must be specified by explicit selectors (see EntitySelector below for
    // more info).
    public private(set) var id:String = ""

    public private(set) var hasId:Bool = false
    // Whether this entity is to be deleted. Relevant only for incremental
    // fetches.
    public private(set) var isDeleted:Bool = false

    public private(set) var hasIsDeleted:Bool = false
    public private(set) var tripUpdate:TransitRealtime.TripUpdate!
    public private(set) var hasTripUpdate:Bool = false
    public private(set) var vehicle:TransitRealtime.VehiclePosition!
    public private(set) var hasVehicle:Bool = false
    public private(set) var alert:TransitRealtime.Alert!
    public private(set) var hasAlert:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !hasId {
        return false
      }
      if hasTripUpdate {
       if !tripUpdate.isInitialized() {
         return false
       }
      }
      if hasVehicle {
       if !vehicle.isInitialized() {
         return false
       }
      }
      if hasAlert {
       if !alert.isInitialized() {
         return false
       }
      }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasId {
        try output.writeString(1, value:id)
      }
      if hasIsDeleted {
        try output.writeBool(2, value:isDeleted)
      }
      if hasTripUpdate {
        try output.writeMessage(3, value:tripUpdate)
      }
      if hasVehicle {
        try output.writeMessage(4, value:vehicle)
      }
      if hasAlert {
        try output.writeMessage(5, value:alert)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(2000))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasId {
        serialize_size += id.computeStringSize(1)
      }
      if hasIsDeleted {
        serialize_size += isDeleted.computeBoolSize(2)
      }
      if hasTripUpdate {
          if let varSizetripUpdate = tripUpdate?.computeMessageSize(3) {
              serialize_size += varSizetripUpdate
          }
      }
      if hasVehicle {
          if let varSizevehicle = vehicle?.computeMessageSize(4) {
              serialize_size += varSizevehicle
          }
      }
      if hasAlert {
          if let varSizealert = alert?.computeMessageSize(5) {
              serialize_size += varSizealert
          }
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TransitRealtime.FeedEntity> {
      var mergedArray = Array<TransitRealtime.FeedEntity>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TransitRealtime.FeedEntity? {
      return try TransitRealtime.FeedEntity.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> TransitRealtime.FeedEntity {
      return try TransitRealtime.FeedEntity.Builder().mergeFromData(data, extensionRegistry:TransitRealtime.GtfsRealtimeProtoTxtRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedEntity {
      return try TransitRealtime.FeedEntity.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> TransitRealtime.FeedEntity {
      return try TransitRealtime.FeedEntity.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedEntity {
      return try TransitRealtime.FeedEntity.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.FeedEntity {
      return try TransitRealtime.FeedEntity.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedEntity {
      return try TransitRealtime.FeedEntity.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> TransitRealtime.FeedEntity.Builder {
      return TransitRealtime.FeedEntity.classBuilder() as! TransitRealtime.FeedEntity.Builder
    }
    public func getBuilder() -> TransitRealtime.FeedEntity.Builder {
      return classBuilder() as! TransitRealtime.FeedEntity.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return TransitRealtime.FeedEntity.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return TransitRealtime.FeedEntity.Builder()
    }
    public func toBuilder() throws -> TransitRealtime.FeedEntity.Builder {
      return try TransitRealtime.FeedEntity.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:TransitRealtime.FeedEntity) throws -> TransitRealtime.FeedEntity.Builder {
      return try TransitRealtime.FeedEntity.Builder().mergeFrom(prototype)
    }
    override public func getDescription(indent:String) throws -> String {
      var output:String = ""
      if hasId {
        output += "\(indent) id: \(id) \n"
      }
      if hasIsDeleted {
        output += "\(indent) isDeleted: \(isDeleted) \n"
      }
      if hasTripUpdate {
        output += "\(indent) tripUpdate {\n"
        if let outDescTripUpdate = tripUpdate {
          output += try outDescTripUpdate.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasVehicle {
        output += "\(indent) vehicle {\n"
        if let outDescVehicle = vehicle {
          output += try outDescVehicle.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasAlert {
        output += "\(indent) alert {\n"
        if let outDescAlert = alert {
          output += try outDescAlert.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(2000), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
               hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasIsDeleted {
               hashCode = (hashCode &* 31) &+ isDeleted.hashValue
            }
            if hasTripUpdate {
                if let hashValuetripUpdate = tripUpdate?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuetripUpdate
                }
            }
            if hasVehicle {
                if let hashValuevehicle = vehicle?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuevehicle
                }
            }
            if hasAlert {
                if let hashValuealert = alert?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuealert
                }
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(2000)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "TransitRealtime.FeedEntity"
    }
    override public func className() -> String {
        return "TransitRealtime.FeedEntity"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return TransitRealtime.FeedEntity.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:TransitRealtime.FeedEntity = TransitRealtime.FeedEntity()
      public func getMessage() -> TransitRealtime.FeedEntity {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasId:Bool {
           get {
                return builderResult.hasId
           }
      }
      public var id:String {
           get {
                return builderResult.id
           }
           set (value) {
               builderResult.hasId = true
               builderResult.id = value
           }
      }
      public func setId(value:String) -> TransitRealtime.FeedEntity.Builder {
        self.id = value
        return self
      }
      public func clearId() -> TransitRealtime.FeedEntity.Builder{
           builderResult.hasId = false
           builderResult.id = ""
           return self
      }
      public var hasIsDeleted:Bool {
           get {
                return builderResult.hasIsDeleted
           }
      }
      public var isDeleted:Bool {
           get {
                return builderResult.isDeleted
           }
           set (value) {
               builderResult.hasIsDeleted = true
               builderResult.isDeleted = value
           }
      }
      public func setIsDeleted(value:Bool) -> TransitRealtime.FeedEntity.Builder {
        self.isDeleted = value
        return self
      }
      public func clearIsDeleted() -> TransitRealtime.FeedEntity.Builder{
           builderResult.hasIsDeleted = false
           builderResult.isDeleted = false
           return self
      }
      public var hasTripUpdate:Bool {
           get {
               return builderResult.hasTripUpdate
           }
      }
      public var tripUpdate:TransitRealtime.TripUpdate! {
           get {
               if tripUpdateBuilder_ != nil {
                  builderResult.tripUpdate = tripUpdateBuilder_.getMessage()
               }
               return builderResult.tripUpdate
           }
           set (value) {
               builderResult.hasTripUpdate = true
               builderResult.tripUpdate = value
           }
      }
      private var tripUpdateBuilder_:TransitRealtime.TripUpdate.Builder! {
           didSet {
              builderResult.hasTripUpdate = true
           }
      }
      public func getTripUpdateBuilder() -> TransitRealtime.TripUpdate.Builder {
        if tripUpdateBuilder_ == nil {
           tripUpdateBuilder_ = TransitRealtime.TripUpdate.Builder()
           builderResult.tripUpdate = tripUpdateBuilder_.getMessage()
           if tripUpdate != nil {
              try! tripUpdateBuilder_.mergeFrom(tripUpdate)
           }
        }
        return tripUpdateBuilder_
      }
      public func setTripUpdate(value:TransitRealtime.TripUpdate!) -> TransitRealtime.FeedEntity.Builder {
        self.tripUpdate = value
        return self
      }
      public func mergeTripUpdate(value:TransitRealtime.TripUpdate) throws -> TransitRealtime.FeedEntity.Builder {
        if builderResult.hasTripUpdate {
          builderResult.tripUpdate = try TransitRealtime.TripUpdate.builderWithPrototype(builderResult.tripUpdate).mergeFrom(value).buildPartial()
        } else {
          builderResult.tripUpdate = value
        }
        builderResult.hasTripUpdate = true
        return self
      }
      public func clearTripUpdate() -> TransitRealtime.FeedEntity.Builder {
        tripUpdateBuilder_ = nil
        builderResult.hasTripUpdate = false
        builderResult.tripUpdate = nil
        return self
      }
      public var hasVehicle:Bool {
           get {
               return builderResult.hasVehicle
           }
      }
      public var vehicle:TransitRealtime.VehiclePosition! {
           get {
               if vehicleBuilder_ != nil {
                  builderResult.vehicle = vehicleBuilder_.getMessage()
               }
               return builderResult.vehicle
           }
           set (value) {
               builderResult.hasVehicle = true
               builderResult.vehicle = value
           }
      }
      private var vehicleBuilder_:TransitRealtime.VehiclePosition.Builder! {
           didSet {
              builderResult.hasVehicle = true
           }
      }
      public func getVehicleBuilder() -> TransitRealtime.VehiclePosition.Builder {
        if vehicleBuilder_ == nil {
           vehicleBuilder_ = TransitRealtime.VehiclePosition.Builder()
           builderResult.vehicle = vehicleBuilder_.getMessage()
           if vehicle != nil {
              try! vehicleBuilder_.mergeFrom(vehicle)
           }
        }
        return vehicleBuilder_
      }
      public func setVehicle(value:TransitRealtime.VehiclePosition!) -> TransitRealtime.FeedEntity.Builder {
        self.vehicle = value
        return self
      }
      public func mergeVehicle(value:TransitRealtime.VehiclePosition) throws -> TransitRealtime.FeedEntity.Builder {
        if builderResult.hasVehicle {
          builderResult.vehicle = try TransitRealtime.VehiclePosition.builderWithPrototype(builderResult.vehicle).mergeFrom(value).buildPartial()
        } else {
          builderResult.vehicle = value
        }
        builderResult.hasVehicle = true
        return self
      }
      public func clearVehicle() -> TransitRealtime.FeedEntity.Builder {
        vehicleBuilder_ = nil
        builderResult.hasVehicle = false
        builderResult.vehicle = nil
        return self
      }
      public var hasAlert:Bool {
           get {
               return builderResult.hasAlert
           }
      }
      public var alert:TransitRealtime.Alert! {
           get {
               if alertBuilder_ != nil {
                  builderResult.alert = alertBuilder_.getMessage()
               }
               return builderResult.alert
           }
           set (value) {
               builderResult.hasAlert = true
               builderResult.alert = value
           }
      }
      private var alertBuilder_:TransitRealtime.Alert.Builder! {
           didSet {
              builderResult.hasAlert = true
           }
      }
      public func getAlertBuilder() -> TransitRealtime.Alert.Builder {
        if alertBuilder_ == nil {
           alertBuilder_ = TransitRealtime.Alert.Builder()
           builderResult.alert = alertBuilder_.getMessage()
           if alert != nil {
              try! alertBuilder_.mergeFrom(alert)
           }
        }
        return alertBuilder_
      }
      public func setAlert(value:TransitRealtime.Alert!) -> TransitRealtime.FeedEntity.Builder {
        self.alert = value
        return self
      }
      public func mergeAlert(value:TransitRealtime.Alert) throws -> TransitRealtime.FeedEntity.Builder {
        if builderResult.hasAlert {
          builderResult.alert = try TransitRealtime.Alert.builderWithPrototype(builderResult.alert).mergeFrom(value).buildPartial()
        } else {
          builderResult.alert = value
        }
        builderResult.hasAlert = true
        return self
      }
      public func clearAlert() -> TransitRealtime.FeedEntity.Builder {
        alertBuilder_ = nil
        builderResult.hasAlert = false
        builderResult.alert = nil
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> TransitRealtime.FeedEntity.Builder {
        builderResult = TransitRealtime.FeedEntity()
        return self
      }
      public override func clone() throws -> TransitRealtime.FeedEntity.Builder {
        return try TransitRealtime.FeedEntity.builderWithPrototype(builderResult)
      }
      public override func build() throws -> TransitRealtime.FeedEntity {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> TransitRealtime.FeedEntity {
        let returnMe:TransitRealtime.FeedEntity = builderResult
        return returnMe
      }
      public func mergeFrom(other:TransitRealtime.FeedEntity) throws -> TransitRealtime.FeedEntity.Builder {
        if other == TransitRealtime.FeedEntity() {
         return self
        }
        if other.hasId {
             id = other.id
        }
        if other.hasIsDeleted {
             isDeleted = other.isDeleted
        }
        if (other.hasTripUpdate) {
            try mergeTripUpdate(other.tripUpdate)
        }
        if (other.hasVehicle) {
            try mergeVehicle(other.vehicle)
        }
        if (other.hasAlert) {
            try mergeAlert(other.alert)
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.FeedEntity.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedEntity.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            id = try input.readString()

          case 16 :
            isDeleted = try input.readBool()

          case 26 :
            let subBuilder:TransitRealtime.TripUpdate.Builder = TransitRealtime.TripUpdate.Builder()
            if hasTripUpdate {
              try subBuilder.mergeFrom(tripUpdate)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            tripUpdate = subBuilder.buildPartial()

          case 34 :
            let subBuilder:TransitRealtime.VehiclePosition.Builder = TransitRealtime.VehiclePosition.Builder()
            if hasVehicle {
              try subBuilder.mergeFrom(vehicle)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            vehicle = subBuilder.buildPartial()

          case 42 :
            let subBuilder:TransitRealtime.Alert.Builder = TransitRealtime.Alert.Builder()
            if hasAlert {
              try subBuilder.mergeFrom(alert)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            alert = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  // Realtime update of the progress of a vehicle along a trip.
  // Depending on the value of ScheduleRelationship, a TripUpdate can specify:
  // - A trip that proceeds along the schedule.
  // - A trip that proceeds along a route but has no fixed schedule.
  // - A trip that have been added or removed with regard to schedule.
  // The updates can be for future, predicted arrival/departure events, or for
  // past events that already occurred.
  // Normally, updates should get more precise and more certain (see
  // uncertainty below) as the events gets closer to current time.
  // Even if that is not possible, the information for past events should be
  // precise and certain. In particular, if an update points to time in the past
  // but its update's uncertainty is not 0, the client should conclude that the
  // update is a (wrong) prediction and that the trip has not completed yet.
  // Note that the update can describe a trip that is already completed.
  // To this end, it is enough to provide an update for the last stop of the trip.
  // If the time of that is in the past, the client will conclude from that that
  // the whole trip is in the past (it is possible, although inconsequential, to
  // also provide updates for preceding stops).
  // This option is most relevant for a trip that has completed ahead of schedule,
  // but according to the schedule, the trip is still proceeding at the current
  // time. Removing the updates for this trip could make the client assume
  // that the trip is still proceeding.
  // Note that the feed provider is allowed, but not required, to purge past
  // updates - this is one case where this would be practically useful.
  final public class TripUpdate : ExtendableMessage, GeneratedMessageProtocol{


    //Nested type declaration start

      // Timing information for a single predicted event (either arrival or
      // departure).
      // Timing consists of delay and/or estimated time, and uncertainty.
      // - delay should be used when the prediction is given relative to some
      //   existing schedule in GTFS.
      // - time should be given whether there is a predicted schedule or not. If
      //   both time and delay are specified, time will take precedence
      //   (although normally, time, if given for a scheduled trip, should be
      //   equal to scheduled time in GTFS + delay).
      // Uncertainty applies equally to both time and delay.
      // The uncertainty roughly specifies the expected error in true delay (but
      // note, we don't yet define its precise statistical meaning). It's possible
      // for the uncertainty to be 0, for example for trains that are driven under
      // computer timing control.
      final public class StopTimeEvent : ExtendableMessage, GeneratedMessageProtocol{
        // Delay (in seconds) can be positive (meaning that the vehicle is late) or
        // negative (meaning that the vehicle is ahead of schedule). Delay of 0
        // means that the vehicle is exactly on time.
        public private(set) var delay:Int32 = Int32(0)

        public private(set) var hasDelay:Bool = false
        // Event as absolute time.
        // In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
        // UTC).
        public private(set) var time:Int64 = Int64(0)

        public private(set) var hasTime:Bool = false
        // If uncertainty is omitted, it is interpreted as unknown.
        // If the prediction is unknown or too uncertain, the delay (or time) field
        // should be empty. In such case, the uncertainty field is ignored.
        // To specify a completely certain prediction, set its uncertainty to 0.
        public private(set) var uncertainty:Int32 = Int32(0)

        public private(set) var hasUncertainty:Bool = false
        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
          if !extensionsAreInitialized() {
           return false
          }
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasDelay {
            try output.writeInt32(1, value:delay)
          }
          if hasTime {
            try output.writeInt64(2, value:time)
          }
          if hasUncertainty {
            try output.writeInt32(3, value:uncertainty)
          }
          try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(2000))
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasDelay {
            serialize_size += delay.computeInt32Size(1)
          }
          if hasTime {
            serialize_size += time.computeInt64Size(2)
          }
          if hasUncertainty {
            serialize_size += uncertainty.computeInt32Size(3)
          }
          serialize_size += extensionsSerializedSize()
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TransitRealtime.TripUpdate.StopTimeEvent> {
          var mergedArray = Array<TransitRealtime.TripUpdate.StopTimeEvent>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TransitRealtime.TripUpdate.StopTimeEvent? {
          return try TransitRealtime.TripUpdate.StopTimeEvent.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(data:NSData) throws -> TransitRealtime.TripUpdate.StopTimeEvent {
          return try TransitRealtime.TripUpdate.StopTimeEvent.Builder().mergeFromData(data, extensionRegistry:TransitRealtime.GtfsRealtimeProtoTxtRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.StopTimeEvent {
          return try TransitRealtime.TripUpdate.StopTimeEvent.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) throws -> TransitRealtime.TripUpdate.StopTimeEvent {
          return try TransitRealtime.TripUpdate.StopTimeEvent.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.StopTimeEvent {
          return try TransitRealtime.TripUpdate.StopTimeEvent.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.TripUpdate.StopTimeEvent {
          return try TransitRealtime.TripUpdate.StopTimeEvent.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.StopTimeEvent {
          return try TransitRealtime.TripUpdate.StopTimeEvent.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
          return TransitRealtime.TripUpdate.StopTimeEvent.classBuilder() as! TransitRealtime.TripUpdate.StopTimeEvent.Builder
        }
        public func getBuilder() -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
          return classBuilder() as! TransitRealtime.TripUpdate.StopTimeEvent.Builder
        }
        public override class func classBuilder() -> MessageBuilder {
          return TransitRealtime.TripUpdate.StopTimeEvent.Builder()
        }
        public override func classBuilder() -> MessageBuilder {
          return TransitRealtime.TripUpdate.StopTimeEvent.Builder()
        }
        public func toBuilder() throws -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
          return try TransitRealtime.TripUpdate.StopTimeEvent.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:TransitRealtime.TripUpdate.StopTimeEvent) throws -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
          return try TransitRealtime.TripUpdate.StopTimeEvent.Builder().mergeFrom(prototype)
        }
        override public func getDescription(indent:String) throws -> String {
          var output:String = ""
          if hasDelay {
            output += "\(indent) delay: \(delay) \n"
          }
          if hasTime {
            output += "\(indent) time: \(time) \n"
          }
          if hasUncertainty {
            output += "\(indent) uncertainty: \(uncertainty) \n"
          }
          output += try getExtensionDescription(Int32(1000), endExclusive:Int32(2000), indent:indent)
          output += unknownFields.getDescription(indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDelay {
                   hashCode = (hashCode &* 31) &+ delay.hashValue
                }
                if hasTime {
                   hashCode = (hashCode &* 31) &+ time.hashValue
                }
                if hasUncertainty {
                   hashCode = (hashCode &* 31) &+ uncertainty.hashValue
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(2000)))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "TransitRealtime.TripUpdate.StopTimeEvent"
        }
        override public func className() -> String {
            return "TransitRealtime.TripUpdate.StopTimeEvent"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return TransitRealtime.TripUpdate.StopTimeEvent.self
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
          private var builderResult:TransitRealtime.TripUpdate.StopTimeEvent = TransitRealtime.TripUpdate.StopTimeEvent()
          public func getMessage() -> TransitRealtime.TripUpdate.StopTimeEvent {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasDelay:Bool {
               get {
                    return builderResult.hasDelay
               }
          }
          public var delay:Int32 {
               get {
                    return builderResult.delay
               }
               set (value) {
                   builderResult.hasDelay = true
                   builderResult.delay = value
               }
          }
          public func setDelay(value:Int32) -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
            self.delay = value
            return self
          }
          public func clearDelay() -> TransitRealtime.TripUpdate.StopTimeEvent.Builder{
               builderResult.hasDelay = false
               builderResult.delay = Int32(0)
               return self
          }
          public var hasTime:Bool {
               get {
                    return builderResult.hasTime
               }
          }
          public var time:Int64 {
               get {
                    return builderResult.time
               }
               set (value) {
                   builderResult.hasTime = true
                   builderResult.time = value
               }
          }
          public func setTime(value:Int64) -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
            self.time = value
            return self
          }
          public func clearTime() -> TransitRealtime.TripUpdate.StopTimeEvent.Builder{
               builderResult.hasTime = false
               builderResult.time = Int64(0)
               return self
          }
          public var hasUncertainty:Bool {
               get {
                    return builderResult.hasUncertainty
               }
          }
          public var uncertainty:Int32 {
               get {
                    return builderResult.uncertainty
               }
               set (value) {
                   builderResult.hasUncertainty = true
                   builderResult.uncertainty = value
               }
          }
          public func setUncertainty(value:Int32) -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
            self.uncertainty = value
            return self
          }
          public func clearUncertainty() -> TransitRealtime.TripUpdate.StopTimeEvent.Builder{
               builderResult.hasUncertainty = false
               builderResult.uncertainty = Int32(0)
               return self
          }
          override public var internalGetResult:ExtendableMessage {
               get {
                   return builderResult
               }
          }
          public override func clear() -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
            builderResult = TransitRealtime.TripUpdate.StopTimeEvent()
            return self
          }
          public override func clone() throws -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
            return try TransitRealtime.TripUpdate.StopTimeEvent.builderWithPrototype(builderResult)
          }
          public override func build() throws -> TransitRealtime.TripUpdate.StopTimeEvent {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> TransitRealtime.TripUpdate.StopTimeEvent {
            let returnMe:TransitRealtime.TripUpdate.StopTimeEvent = builderResult
            return returnMe
          }
          public func mergeFrom(other:TransitRealtime.TripUpdate.StopTimeEvent) throws -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
            if other == TransitRealtime.TripUpdate.StopTimeEvent() {
             return self
            }
            if other.hasDelay {
                 delay = other.delay
            }
            if other.hasTime {
                 time = other.time
            }
            if other.hasUncertainty {
                 uncertainty = other.uncertainty
            }
            try mergeExtensionFields(other)
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let protobufTag = try input.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8 :
                delay = try input.readInt32()

              case 16 :
                time = try input.readInt64()

              case 24 :
                uncertainty = try input.readInt32()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      // Realtime update for arrival and/or departure events for a given stop on a
      // trip. Updates can be supplied for both past and future events.
      // The producer is allowed, although not required, to drop past events.
      final public class StopTimeUpdate : ExtendableMessage, GeneratedMessageProtocol{


          //Enum type declaration start 

          // The relation between this StopTime and the static schedule.
          public enum ScheduleRelationship:Int32, CustomDebugStringConvertible, CustomStringConvertible {
            // The vehicle is proceeding in accordance with its static schedule of
            // stops, although not necessarily according to the times of the schedule.
            // At least one of arrival and departure must be provided. If the schedule
            // for this stop contains both arrival and departure times then so must
            // this update.
            case Scheduled = 0

            // The stop is skipped, i.e., the vehicle will not stop at this stop.
            // Arrival and departure are optional.
            case Skipped = 1

            // No data is given for this stop. The main intention for this value is to
            // give the predictions only for part of a trip, i.e., if the last update
            // for a trip has a NO_DATA specifier, then StopTimes for the rest of the
            // stops in the trip are considered to be unspecified as well.
            // Neither arrival nor departure should be supplied.
            case NoData = 2

            public var debugDescription:String { return getDescription() }
            public var description:String { return getDescription() }
            private func getDescription() -> String { 
                switch self {
                    case .Scheduled: return ".Scheduled"
                    case .Skipped: return ".Skipped"
                    case .NoData: return ".NoData"
                }
            }
          }

          //Enum type declaration end 

        // Must be the same as in stop_times.txt in the corresponding GTFS feed.
        public private(set) var stopSequence:UInt32 = UInt32(0)

        public private(set) var hasStopSequence:Bool = false
        // Must be the same as in stops.txt in the corresponding GTFS feed.
        public private(set) var stopId:String = ""

        public private(set) var hasStopId:Bool = false
        public private(set) var arrival:TransitRealtime.TripUpdate.StopTimeEvent!
        public private(set) var hasArrival:Bool = false
        public private(set) var departure:TransitRealtime.TripUpdate.StopTimeEvent!
        public private(set) var hasDeparture:Bool = false
        public private(set) var scheduleRelationship:TransitRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship = TransitRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.Scheduled
        public private(set) var hasScheduleRelationship:Bool = false
        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
          if hasArrival {
           if !arrival.isInitialized() {
             return false
           }
          }
          if hasDeparture {
           if !departure.isInitialized() {
             return false
           }
          }
          if !extensionsAreInitialized() {
           return false
          }
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasStopSequence {
            try output.writeUInt32(1, value:stopSequence)
          }
          if hasArrival {
            try output.writeMessage(2, value:arrival)
          }
          if hasDeparture {
            try output.writeMessage(3, value:departure)
          }
          if hasStopId {
            try output.writeString(4, value:stopId)
          }
          if hasScheduleRelationship {
            try output.writeEnum(5, value:scheduleRelationship.rawValue)
          }
          try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(2000))
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasStopSequence {
            serialize_size += stopSequence.computeUInt32Size(1)
          }
          if hasArrival {
              if let varSizearrival = arrival?.computeMessageSize(2) {
                  serialize_size += varSizearrival
              }
          }
          if hasDeparture {
              if let varSizedeparture = departure?.computeMessageSize(3) {
                  serialize_size += varSizedeparture
              }
          }
          if hasStopId {
            serialize_size += stopId.computeStringSize(4)
          }
          if (hasScheduleRelationship) {
            serialize_size += scheduleRelationship.rawValue.computeEnumSize(5)
          }
          serialize_size += extensionsSerializedSize()
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TransitRealtime.TripUpdate.StopTimeUpdate> {
          var mergedArray = Array<TransitRealtime.TripUpdate.StopTimeUpdate>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TransitRealtime.TripUpdate.StopTimeUpdate? {
          return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(data:NSData) throws -> TransitRealtime.TripUpdate.StopTimeUpdate {
          return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder().mergeFromData(data, extensionRegistry:TransitRealtime.GtfsRealtimeProtoTxtRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.StopTimeUpdate {
          return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) throws -> TransitRealtime.TripUpdate.StopTimeUpdate {
          return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.StopTimeUpdate {
          return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.TripUpdate.StopTimeUpdate {
          return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.StopTimeUpdate {
          return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
          return TransitRealtime.TripUpdate.StopTimeUpdate.classBuilder() as! TransitRealtime.TripUpdate.StopTimeUpdate.Builder
        }
        public func getBuilder() -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
          return classBuilder() as! TransitRealtime.TripUpdate.StopTimeUpdate.Builder
        }
        public override class func classBuilder() -> MessageBuilder {
          return TransitRealtime.TripUpdate.StopTimeUpdate.Builder()
        }
        public override func classBuilder() -> MessageBuilder {
          return TransitRealtime.TripUpdate.StopTimeUpdate.Builder()
        }
        public func toBuilder() throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
          return try TransitRealtime.TripUpdate.StopTimeUpdate.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:TransitRealtime.TripUpdate.StopTimeUpdate) throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
          return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder().mergeFrom(prototype)
        }
        override public func getDescription(indent:String) throws -> String {
          var output:String = ""
          if hasStopSequence {
            output += "\(indent) stopSequence: \(stopSequence) \n"
          }
          if hasArrival {
            output += "\(indent) arrival {\n"
            if let outDescArrival = arrival {
              output += try outDescArrival.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasDeparture {
            output += "\(indent) departure {\n"
            if let outDescDeparture = departure {
              output += try outDescDeparture.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasStopId {
            output += "\(indent) stopId: \(stopId) \n"
          }
          if (hasScheduleRelationship) {
            output += "\(indent) scheduleRelationship: \(scheduleRelationship.description)\n"
          }
          output += try getExtensionDescription(Int32(1000), endExclusive:Int32(2000), indent:indent)
          output += unknownFields.getDescription(indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStopSequence {
                   hashCode = (hashCode &* 31) &+ stopSequence.hashValue
                }
                if hasArrival {
                    if let hashValuearrival = arrival?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuearrival
                    }
                }
                if hasDeparture {
                    if let hashValuedeparture = departure?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedeparture
                    }
                }
                if hasStopId {
                   hashCode = (hashCode &* 31) &+ stopId.hashValue
                }
                if hasScheduleRelationship {
                   hashCode = (hashCode &* 31) &+ Int(scheduleRelationship.rawValue)
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(2000)))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "TransitRealtime.TripUpdate.StopTimeUpdate"
        }
        override public func className() -> String {
            return "TransitRealtime.TripUpdate.StopTimeUpdate"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return TransitRealtime.TripUpdate.StopTimeUpdate.self
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
          private var builderResult:TransitRealtime.TripUpdate.StopTimeUpdate = TransitRealtime.TripUpdate.StopTimeUpdate()
          public func getMessage() -> TransitRealtime.TripUpdate.StopTimeUpdate {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasStopSequence:Bool {
               get {
                    return builderResult.hasStopSequence
               }
          }
          public var stopSequence:UInt32 {
               get {
                    return builderResult.stopSequence
               }
               set (value) {
                   builderResult.hasStopSequence = true
                   builderResult.stopSequence = value
               }
          }
          public func setStopSequence(value:UInt32) -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
            self.stopSequence = value
            return self
          }
          public func clearStopSequence() -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder{
               builderResult.hasStopSequence = false
               builderResult.stopSequence = UInt32(0)
               return self
          }
          public var hasStopId:Bool {
               get {
                    return builderResult.hasStopId
               }
          }
          public var stopId:String {
               get {
                    return builderResult.stopId
               }
               set (value) {
                   builderResult.hasStopId = true
                   builderResult.stopId = value
               }
          }
          public func setStopId(value:String) -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
            self.stopId = value
            return self
          }
          public func clearStopId() -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder{
               builderResult.hasStopId = false
               builderResult.stopId = ""
               return self
          }
          public var hasArrival:Bool {
               get {
                   return builderResult.hasArrival
               }
          }
          public var arrival:TransitRealtime.TripUpdate.StopTimeEvent! {
               get {
                   if arrivalBuilder_ != nil {
                      builderResult.arrival = arrivalBuilder_.getMessage()
                   }
                   return builderResult.arrival
               }
               set (value) {
                   builderResult.hasArrival = true
                   builderResult.arrival = value
               }
          }
          private var arrivalBuilder_:TransitRealtime.TripUpdate.StopTimeEvent.Builder! {
               didSet {
                  builderResult.hasArrival = true
               }
          }
          public func getArrivalBuilder() -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
            if arrivalBuilder_ == nil {
               arrivalBuilder_ = TransitRealtime.TripUpdate.StopTimeEvent.Builder()
               builderResult.arrival = arrivalBuilder_.getMessage()
               if arrival != nil {
                  try! arrivalBuilder_.mergeFrom(arrival)
               }
            }
            return arrivalBuilder_
          }
          public func setArrival(value:TransitRealtime.TripUpdate.StopTimeEvent!) -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
            self.arrival = value
            return self
          }
          public func mergeArrival(value:TransitRealtime.TripUpdate.StopTimeEvent) throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
            if builderResult.hasArrival {
              builderResult.arrival = try TransitRealtime.TripUpdate.StopTimeEvent.builderWithPrototype(builderResult.arrival).mergeFrom(value).buildPartial()
            } else {
              builderResult.arrival = value
            }
            builderResult.hasArrival = true
            return self
          }
          public func clearArrival() -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
            arrivalBuilder_ = nil
            builderResult.hasArrival = false
            builderResult.arrival = nil
            return self
          }
          public var hasDeparture:Bool {
               get {
                   return builderResult.hasDeparture
               }
          }
          public var departure:TransitRealtime.TripUpdate.StopTimeEvent! {
               get {
                   if departureBuilder_ != nil {
                      builderResult.departure = departureBuilder_.getMessage()
                   }
                   return builderResult.departure
               }
               set (value) {
                   builderResult.hasDeparture = true
                   builderResult.departure = value
               }
          }
          private var departureBuilder_:TransitRealtime.TripUpdate.StopTimeEvent.Builder! {
               didSet {
                  builderResult.hasDeparture = true
               }
          }
          public func getDepartureBuilder() -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
            if departureBuilder_ == nil {
               departureBuilder_ = TransitRealtime.TripUpdate.StopTimeEvent.Builder()
               builderResult.departure = departureBuilder_.getMessage()
               if departure != nil {
                  try! departureBuilder_.mergeFrom(departure)
               }
            }
            return departureBuilder_
          }
          public func setDeparture(value:TransitRealtime.TripUpdate.StopTimeEvent!) -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
            self.departure = value
            return self
          }
          public func mergeDeparture(value:TransitRealtime.TripUpdate.StopTimeEvent) throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
            if builderResult.hasDeparture {
              builderResult.departure = try TransitRealtime.TripUpdate.StopTimeEvent.builderWithPrototype(builderResult.departure).mergeFrom(value).buildPartial()
            } else {
              builderResult.departure = value
            }
            builderResult.hasDeparture = true
            return self
          }
          public func clearDeparture() -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
            departureBuilder_ = nil
            builderResult.hasDeparture = false
            builderResult.departure = nil
            return self
          }
            public var hasScheduleRelationship:Bool{
                get {
                    return builderResult.hasScheduleRelationship
                }
            }
            public var scheduleRelationship:TransitRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship {
                get {
                    return builderResult.scheduleRelationship
                }
                set (value) {
                    builderResult.hasScheduleRelationship = true
                    builderResult.scheduleRelationship = value
                }
            }
            public func setScheduleRelationship(value:TransitRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship) -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
              self.scheduleRelationship = value
              return self
            }
            public func clearScheduleRelationship() -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
               builderResult.hasScheduleRelationship = false
               builderResult.scheduleRelationship = .Scheduled
               return self
            }
          override public var internalGetResult:ExtendableMessage {
               get {
                   return builderResult
               }
          }
          public override func clear() -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
            builderResult = TransitRealtime.TripUpdate.StopTimeUpdate()
            return self
          }
          public override func clone() throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
            return try TransitRealtime.TripUpdate.StopTimeUpdate.builderWithPrototype(builderResult)
          }
          public override func build() throws -> TransitRealtime.TripUpdate.StopTimeUpdate {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> TransitRealtime.TripUpdate.StopTimeUpdate {
            let returnMe:TransitRealtime.TripUpdate.StopTimeUpdate = builderResult
            return returnMe
          }
          public func mergeFrom(other:TransitRealtime.TripUpdate.StopTimeUpdate) throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
            if other == TransitRealtime.TripUpdate.StopTimeUpdate() {
             return self
            }
            if other.hasStopSequence {
                 stopSequence = other.stopSequence
            }
            if other.hasStopId {
                 stopId = other.stopId
            }
            if (other.hasArrival) {
                try mergeArrival(other.arrival)
            }
            if (other.hasDeparture) {
                try mergeDeparture(other.departure)
            }
            if other.hasScheduleRelationship {
                 scheduleRelationship = other.scheduleRelationship
            }
            try mergeExtensionFields(other)
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let protobufTag = try input.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8 :
                stopSequence = try input.readUInt32()

              case 18 :
                let subBuilder:TransitRealtime.TripUpdate.StopTimeEvent.Builder = TransitRealtime.TripUpdate.StopTimeEvent.Builder()
                if hasArrival {
                  try subBuilder.mergeFrom(arrival)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                arrival = subBuilder.buildPartial()

              case 26 :
                let subBuilder:TransitRealtime.TripUpdate.StopTimeEvent.Builder = TransitRealtime.TripUpdate.StopTimeEvent.Builder()
                if hasDeparture {
                  try subBuilder.mergeFrom(departure)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                departure = subBuilder.buildPartial()

              case 34 :
                stopId = try input.readString()

              case 40 :
                let valueIntscheduleRelationship = try input.readEnum()
                if let enumsscheduleRelationship = TransitRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship(rawValue:valueIntscheduleRelationship){
                     scheduleRelationship = enumsscheduleRelationship
                } else {
                     try unknownFieldsBuilder.mergeVarintField(5, value:Int64(valueIntscheduleRelationship))
                }

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end

    public private(set) var trip:TransitRealtime.TripDescriptor!
    public private(set) var hasTrip:Bool = false
    public private(set) var vehicle:TransitRealtime.VehicleDescriptor!
    public private(set) var hasVehicle:Bool = false
    public private(set) var stopTimeUpdate:Array<TransitRealtime.TripUpdate.StopTimeUpdate>  = Array<TransitRealtime.TripUpdate.StopTimeUpdate>()
    // Moment at which the vehicle's real-time progress was measured. In POSIX
    // time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
    public private(set) var timestamp:UInt64 = UInt64(0)

    public private(set) var hasTimestamp:Bool = false
    // The current schedule deviation for the trip.  Delay should only be
    // specified when the prediction is given relative to some existing schedule
    // in GTFS.
    // Delay (in seconds) can be positive (meaning that the vehicle is late) or
    // negative (meaning that the vehicle is ahead of schedule). Delay of 0
    // means that the vehicle is exactly on time.
    // Delay information in StopTimeUpdates take precedent of trip-level delay
    // information, such that trip-level delay is only propagated until the next
    // stop along the trip with a StopTimeUpdate delay value specified.
    // Feed providers are strongly encouraged to provide a TripUpdate.timestamp
    // value indicating when the delay value was last updated, in order to
    // evaluate the freshness of the data.
    // NOTE: This field is still experimental, and subject to change. It may be
    // formally adopted in the future.
    public private(set) var delay:Int32 = Int32(0)

    public private(set) var hasDelay:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !hasTrip {
        return false
      }
      if !trip.isInitialized() {
        return false
      }
      if hasVehicle {
       if !vehicle.isInitialized() {
         return false
       }
      }
      var isInitstopTimeUpdate:Bool = true
      for oneElementstopTimeUpdate in stopTimeUpdate {
          if (!oneElementstopTimeUpdate.isInitialized()) {
              isInitstopTimeUpdate = false
              break 
          }
      }
      if !isInitstopTimeUpdate {
       return isInitstopTimeUpdate
       }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasTrip {
        try output.writeMessage(1, value:trip)
      }
      for oneElementstopTimeUpdate in stopTimeUpdate {
          try output.writeMessage(2, value:oneElementstopTimeUpdate)
      }
      if hasVehicle {
        try output.writeMessage(3, value:vehicle)
      }
      if hasTimestamp {
        try output.writeUInt64(4, value:timestamp)
      }
      if hasDelay {
        try output.writeInt32(5, value:delay)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(2000))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasTrip {
          if let varSizetrip = trip?.computeMessageSize(1) {
              serialize_size += varSizetrip
          }
      }
      for oneElementstopTimeUpdate in stopTimeUpdate {
          serialize_size += oneElementstopTimeUpdate.computeMessageSize(2)
      }
      if hasVehicle {
          if let varSizevehicle = vehicle?.computeMessageSize(3) {
              serialize_size += varSizevehicle
          }
      }
      if hasTimestamp {
        serialize_size += timestamp.computeUInt64Size(4)
      }
      if hasDelay {
        serialize_size += delay.computeInt32Size(5)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TransitRealtime.TripUpdate> {
      var mergedArray = Array<TransitRealtime.TripUpdate>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TransitRealtime.TripUpdate? {
      return try TransitRealtime.TripUpdate.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> TransitRealtime.TripUpdate {
      return try TransitRealtime.TripUpdate.Builder().mergeFromData(data, extensionRegistry:TransitRealtime.GtfsRealtimeProtoTxtRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate {
      return try TransitRealtime.TripUpdate.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> TransitRealtime.TripUpdate {
      return try TransitRealtime.TripUpdate.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate {
      return try TransitRealtime.TripUpdate.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.TripUpdate {
      return try TransitRealtime.TripUpdate.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate {
      return try TransitRealtime.TripUpdate.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> TransitRealtime.TripUpdate.Builder {
      return TransitRealtime.TripUpdate.classBuilder() as! TransitRealtime.TripUpdate.Builder
    }
    public func getBuilder() -> TransitRealtime.TripUpdate.Builder {
      return classBuilder() as! TransitRealtime.TripUpdate.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return TransitRealtime.TripUpdate.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return TransitRealtime.TripUpdate.Builder()
    }
    public func toBuilder() throws -> TransitRealtime.TripUpdate.Builder {
      return try TransitRealtime.TripUpdate.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:TransitRealtime.TripUpdate) throws -> TransitRealtime.TripUpdate.Builder {
      return try TransitRealtime.TripUpdate.Builder().mergeFrom(prototype)
    }
    override public func getDescription(indent:String) throws -> String {
      var output:String = ""
      if hasTrip {
        output += "\(indent) trip {\n"
        if let outDescTrip = trip {
          output += try outDescTrip.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      var stopTimeUpdateElementIndex:Int = 0
      for oneElementstopTimeUpdate in stopTimeUpdate {
          output += "\(indent) stopTimeUpdate[\(stopTimeUpdateElementIndex)] {\n"
          output += try oneElementstopTimeUpdate.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          stopTimeUpdateElementIndex += 1
      }
      if hasVehicle {
        output += "\(indent) vehicle {\n"
        if let outDescVehicle = vehicle {
          output += try outDescVehicle.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasTimestamp {
        output += "\(indent) timestamp: \(timestamp) \n"
      }
      if hasDelay {
        output += "\(indent) delay: \(delay) \n"
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(2000), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasTrip {
                if let hashValuetrip = trip?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuetrip
                }
            }
            for oneElementstopTimeUpdate in stopTimeUpdate {
                hashCode = (hashCode &* 31) &+ oneElementstopTimeUpdate.hashValue
            }
            if hasVehicle {
                if let hashValuevehicle = vehicle?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuevehicle
                }
            }
            if hasTimestamp {
               hashCode = (hashCode &* 31) &+ timestamp.hashValue
            }
            if hasDelay {
               hashCode = (hashCode &* 31) &+ delay.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(2000)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "TransitRealtime.TripUpdate"
    }
    override public func className() -> String {
        return "TransitRealtime.TripUpdate"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return TransitRealtime.TripUpdate.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:TransitRealtime.TripUpdate = TransitRealtime.TripUpdate()
      public func getMessage() -> TransitRealtime.TripUpdate {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasTrip:Bool {
           get {
               return builderResult.hasTrip
           }
      }
      public var trip:TransitRealtime.TripDescriptor! {
           get {
               if tripBuilder_ != nil {
                  builderResult.trip = tripBuilder_.getMessage()
               }
               return builderResult.trip
           }
           set (value) {
               builderResult.hasTrip = true
               builderResult.trip = value
           }
      }
      private var tripBuilder_:TransitRealtime.TripDescriptor.Builder! {
           didSet {
              builderResult.hasTrip = true
           }
      }
      public func getTripBuilder() -> TransitRealtime.TripDescriptor.Builder {
        if tripBuilder_ == nil {
           tripBuilder_ = TransitRealtime.TripDescriptor.Builder()
           builderResult.trip = tripBuilder_.getMessage()
           if trip != nil {
              try! tripBuilder_.mergeFrom(trip)
           }
        }
        return tripBuilder_
      }
      public func setTrip(value:TransitRealtime.TripDescriptor!) -> TransitRealtime.TripUpdate.Builder {
        self.trip = value
        return self
      }
      public func mergeTrip(value:TransitRealtime.TripDescriptor) throws -> TransitRealtime.TripUpdate.Builder {
        if builderResult.hasTrip {
          builderResult.trip = try TransitRealtime.TripDescriptor.builderWithPrototype(builderResult.trip).mergeFrom(value).buildPartial()
        } else {
          builderResult.trip = value
        }
        builderResult.hasTrip = true
        return self
      }
      public func clearTrip() -> TransitRealtime.TripUpdate.Builder {
        tripBuilder_ = nil
        builderResult.hasTrip = false
        builderResult.trip = nil
        return self
      }
      public var hasVehicle:Bool {
           get {
               return builderResult.hasVehicle
           }
      }
      public var vehicle:TransitRealtime.VehicleDescriptor! {
           get {
               if vehicleBuilder_ != nil {
                  builderResult.vehicle = vehicleBuilder_.getMessage()
               }
               return builderResult.vehicle
           }
           set (value) {
               builderResult.hasVehicle = true
               builderResult.vehicle = value
           }
      }
      private var vehicleBuilder_:TransitRealtime.VehicleDescriptor.Builder! {
           didSet {
              builderResult.hasVehicle = true
           }
      }
      public func getVehicleBuilder() -> TransitRealtime.VehicleDescriptor.Builder {
        if vehicleBuilder_ == nil {
           vehicleBuilder_ = TransitRealtime.VehicleDescriptor.Builder()
           builderResult.vehicle = vehicleBuilder_.getMessage()
           if vehicle != nil {
              try! vehicleBuilder_.mergeFrom(vehicle)
           }
        }
        return vehicleBuilder_
      }
      public func setVehicle(value:TransitRealtime.VehicleDescriptor!) -> TransitRealtime.TripUpdate.Builder {
        self.vehicle = value
        return self
      }
      public func mergeVehicle(value:TransitRealtime.VehicleDescriptor) throws -> TransitRealtime.TripUpdate.Builder {
        if builderResult.hasVehicle {
          builderResult.vehicle = try TransitRealtime.VehicleDescriptor.builderWithPrototype(builderResult.vehicle).mergeFrom(value).buildPartial()
        } else {
          builderResult.vehicle = value
        }
        builderResult.hasVehicle = true
        return self
      }
      public func clearVehicle() -> TransitRealtime.TripUpdate.Builder {
        vehicleBuilder_ = nil
        builderResult.hasVehicle = false
        builderResult.vehicle = nil
        return self
      }
      public var stopTimeUpdate:Array<TransitRealtime.TripUpdate.StopTimeUpdate> {
           get {
               return builderResult.stopTimeUpdate
           }
           set (value) {
               builderResult.stopTimeUpdate = value
           }
      }
      public func setStopTimeUpdate(value:Array<TransitRealtime.TripUpdate.StopTimeUpdate>) -> TransitRealtime.TripUpdate.Builder {
        self.stopTimeUpdate = value
        return self
      }
      public func clearStopTimeUpdate() -> TransitRealtime.TripUpdate.Builder {
        builderResult.stopTimeUpdate.removeAll(keepCapacity: false)
        return self
      }
      public var hasTimestamp:Bool {
           get {
                return builderResult.hasTimestamp
           }
      }
      public var timestamp:UInt64 {
           get {
                return builderResult.timestamp
           }
           set (value) {
               builderResult.hasTimestamp = true
               builderResult.timestamp = value
           }
      }
      public func setTimestamp(value:UInt64) -> TransitRealtime.TripUpdate.Builder {
        self.timestamp = value
        return self
      }
      public func clearTimestamp() -> TransitRealtime.TripUpdate.Builder{
           builderResult.hasTimestamp = false
           builderResult.timestamp = UInt64(0)
           return self
      }
      public var hasDelay:Bool {
           get {
                return builderResult.hasDelay
           }
      }
      public var delay:Int32 {
           get {
                return builderResult.delay
           }
           set (value) {
               builderResult.hasDelay = true
               builderResult.delay = value
           }
      }
      public func setDelay(value:Int32) -> TransitRealtime.TripUpdate.Builder {
        self.delay = value
        return self
      }
      public func clearDelay() -> TransitRealtime.TripUpdate.Builder{
           builderResult.hasDelay = false
           builderResult.delay = Int32(0)
           return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> TransitRealtime.TripUpdate.Builder {
        builderResult = TransitRealtime.TripUpdate()
        return self
      }
      public override func clone() throws -> TransitRealtime.TripUpdate.Builder {
        return try TransitRealtime.TripUpdate.builderWithPrototype(builderResult)
      }
      public override func build() throws -> TransitRealtime.TripUpdate {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> TransitRealtime.TripUpdate {
        let returnMe:TransitRealtime.TripUpdate = builderResult
        return returnMe
      }
      public func mergeFrom(other:TransitRealtime.TripUpdate) throws -> TransitRealtime.TripUpdate.Builder {
        if other == TransitRealtime.TripUpdate() {
         return self
        }
        if (other.hasTrip) {
            try mergeTrip(other.trip)
        }
        if (other.hasVehicle) {
            try mergeVehicle(other.vehicle)
        }
        if !other.stopTimeUpdate.isEmpty  {
           builderResult.stopTimeUpdate += other.stopTimeUpdate
        }
        if other.hasTimestamp {
             timestamp = other.timestamp
        }
        if other.hasDelay {
             delay = other.delay
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.TripUpdate.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            let subBuilder:TransitRealtime.TripDescriptor.Builder = TransitRealtime.TripDescriptor.Builder()
            if hasTrip {
              try subBuilder.mergeFrom(trip)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            trip = subBuilder.buildPartial()

          case 18 :
            let subBuilder = TransitRealtime.TripUpdate.StopTimeUpdate.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            stopTimeUpdate += [subBuilder.buildPartial()]

          case 26 :
            let subBuilder:TransitRealtime.VehicleDescriptor.Builder = TransitRealtime.VehicleDescriptor.Builder()
            if hasVehicle {
              try subBuilder.mergeFrom(vehicle)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            vehicle = subBuilder.buildPartial()

          case 32 :
            timestamp = try input.readUInt64()

          case 40 :
            delay = try input.readInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  // Realtime positioning information for a given vehicle.
  final public class VehiclePosition : ExtendableMessage, GeneratedMessageProtocol{


      //Enum type declaration start 

      public enum VehicleStopStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        // The vehicle is just about to arrive at the stop (on a stop
        // display, the vehicle symbol typically flashes).
        case IncomingAt = 0

        // The vehicle is standing at the stop.
        case StoppedAt = 1

        // The vehicle has departed and is in transit to the next stop.
        case InTransitTo = 2

        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .IncomingAt: return ".IncomingAt"
                case .StoppedAt: return ".StoppedAt"
                case .InTransitTo: return ".InTransitTo"
            }
        }
      }

      //Enum type declaration end 



      //Enum type declaration start 

      // Congestion level that is affecting this vehicle.
      public enum CongestionLevel:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case UnknownCongestionLevel = 0
        case RunningSmoothly = 1
        case StopAndGo = 2
        case Congestion = 3

        // People leaving their cars.
        case SevereCongestion = 4

        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .UnknownCongestionLevel: return ".UnknownCongestionLevel"
                case .RunningSmoothly: return ".RunningSmoothly"
                case .StopAndGo: return ".StopAndGo"
                case .Congestion: return ".Congestion"
                case .SevereCongestion: return ".SevereCongestion"
            }
        }
      }

      //Enum type declaration end 



      //Enum type declaration start 

      // The degree of passenger occupancy of the vehicle. This field is still
      // experimental, and subject to change. It may be formally adopted in the
      // future.
      public enum OccupancyStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        // The vehicle is considered empty by most measures, and has few or no
        // passengers onboard, but is still accepting passengers.
        case Empty = 0

        // The vehicle has a relatively large percentage of seats available.
        // What percentage of free seats out of the total seats available is to be
        // considered large enough to fall into this category is determined at the
        // discretion of the producer.
        case ManySeatsAvailable = 1

        // The vehicle has a relatively small percentage of seats available.
        // What percentage of free seats out of the total seats available is to be
        // considered small enough to fall into this category is determined at the
        // discretion of the feed producer.
        case FewSeatsAvailable = 2

        // The vehicle can currently accommodate only standing passengers.
        case StandingRoomOnly = 3

        // The vehicle can currently accommodate only standing passengers
        // and has limited space for them.
        case CrushedStandingRoomOnly = 4

        // The vehicle is considered full by most measures, but may still be
        // allowing passengers to board.
        case Full = 5

        // The vehicle is not accepting additional passengers.
        case NotAcceptingPassengers = 6

        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Empty: return ".Empty"
                case .ManySeatsAvailable: return ".ManySeatsAvailable"
                case .FewSeatsAvailable: return ".FewSeatsAvailable"
                case .StandingRoomOnly: return ".StandingRoomOnly"
                case .CrushedStandingRoomOnly: return ".CrushedStandingRoomOnly"
                case .Full: return ".Full"
                case .NotAcceptingPassengers: return ".NotAcceptingPassengers"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var trip:TransitRealtime.TripDescriptor!
    public private(set) var hasTrip:Bool = false
    public private(set) var vehicle:TransitRealtime.VehicleDescriptor!
    public private(set) var hasVehicle:Bool = false
    public private(set) var position:TransitRealtime.Position!
    public private(set) var hasPosition:Bool = false
    // The stop sequence index of the current stop. The meaning of
    // current_stop_sequence (i.e., the stop that it refers to) is determined by
    // current_status.
    // If current_status is missing IN_TRANSIT_TO is assumed.
    public private(set) var currentStopSequence:UInt32 = UInt32(0)

    public private(set) var hasCurrentStopSequence:Bool = false
    // Identifies the current stop. The value must be the same as in stops.txt in
    // the corresponding GTFS feed.
    public private(set) var stopId:String = ""

    public private(set) var hasStopId:Bool = false
    public private(set) var currentStatus:TransitRealtime.VehiclePosition.VehicleStopStatus = TransitRealtime.VehiclePosition.VehicleStopStatus.InTransitTo
    public private(set) var hasCurrentStatus:Bool = false
    // Moment at which the vehicle's position was measured. In POSIX time
    // (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
    public private(set) var timestamp:UInt64 = UInt64(0)

    public private(set) var hasTimestamp:Bool = false
    public private(set) var congestionLevel:TransitRealtime.VehiclePosition.CongestionLevel = TransitRealtime.VehiclePosition.CongestionLevel.UnknownCongestionLevel
    public private(set) var hasCongestionLevel:Bool = false
    public private(set) var occupancyStatus:TransitRealtime.VehiclePosition.OccupancyStatus = TransitRealtime.VehiclePosition.OccupancyStatus.Empty
    public private(set) var hasOccupancyStatus:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasTrip {
       if !trip.isInitialized() {
         return false
       }
      }
      if hasVehicle {
       if !vehicle.isInitialized() {
         return false
       }
      }
      if hasPosition {
       if !position.isInitialized() {
         return false
       }
      }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasTrip {
        try output.writeMessage(1, value:trip)
      }
      if hasPosition {
        try output.writeMessage(2, value:position)
      }
      if hasCurrentStopSequence {
        try output.writeUInt32(3, value:currentStopSequence)
      }
      if hasCurrentStatus {
        try output.writeEnum(4, value:currentStatus.rawValue)
      }
      if hasTimestamp {
        try output.writeUInt64(5, value:timestamp)
      }
      if hasCongestionLevel {
        try output.writeEnum(6, value:congestionLevel.rawValue)
      }
      if hasStopId {
        try output.writeString(7, value:stopId)
      }
      if hasVehicle {
        try output.writeMessage(8, value:vehicle)
      }
      if hasOccupancyStatus {
        try output.writeEnum(9, value:occupancyStatus.rawValue)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(2000))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasTrip {
          if let varSizetrip = trip?.computeMessageSize(1) {
              serialize_size += varSizetrip
          }
      }
      if hasPosition {
          if let varSizeposition = position?.computeMessageSize(2) {
              serialize_size += varSizeposition
          }
      }
      if hasCurrentStopSequence {
        serialize_size += currentStopSequence.computeUInt32Size(3)
      }
      if (hasCurrentStatus) {
        serialize_size += currentStatus.rawValue.computeEnumSize(4)
      }
      if hasTimestamp {
        serialize_size += timestamp.computeUInt64Size(5)
      }
      if (hasCongestionLevel) {
        serialize_size += congestionLevel.rawValue.computeEnumSize(6)
      }
      if hasStopId {
        serialize_size += stopId.computeStringSize(7)
      }
      if hasVehicle {
          if let varSizevehicle = vehicle?.computeMessageSize(8) {
              serialize_size += varSizevehicle
          }
      }
      if (hasOccupancyStatus) {
        serialize_size += occupancyStatus.rawValue.computeEnumSize(9)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TransitRealtime.VehiclePosition> {
      var mergedArray = Array<TransitRealtime.VehiclePosition>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TransitRealtime.VehiclePosition? {
      return try TransitRealtime.VehiclePosition.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> TransitRealtime.VehiclePosition {
      return try TransitRealtime.VehiclePosition.Builder().mergeFromData(data, extensionRegistry:TransitRealtime.GtfsRealtimeProtoTxtRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.VehiclePosition {
      return try TransitRealtime.VehiclePosition.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> TransitRealtime.VehiclePosition {
      return try TransitRealtime.VehiclePosition.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.VehiclePosition {
      return try TransitRealtime.VehiclePosition.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.VehiclePosition {
      return try TransitRealtime.VehiclePosition.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.VehiclePosition {
      return try TransitRealtime.VehiclePosition.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> TransitRealtime.VehiclePosition.Builder {
      return TransitRealtime.VehiclePosition.classBuilder() as! TransitRealtime.VehiclePosition.Builder
    }
    public func getBuilder() -> TransitRealtime.VehiclePosition.Builder {
      return classBuilder() as! TransitRealtime.VehiclePosition.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return TransitRealtime.VehiclePosition.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return TransitRealtime.VehiclePosition.Builder()
    }
    public func toBuilder() throws -> TransitRealtime.VehiclePosition.Builder {
      return try TransitRealtime.VehiclePosition.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:TransitRealtime.VehiclePosition) throws -> TransitRealtime.VehiclePosition.Builder {
      return try TransitRealtime.VehiclePosition.Builder().mergeFrom(prototype)
    }
    override public func getDescription(indent:String) throws -> String {
      var output:String = ""
      if hasTrip {
        output += "\(indent) trip {\n"
        if let outDescTrip = trip {
          output += try outDescTrip.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasPosition {
        output += "\(indent) position {\n"
        if let outDescPosition = position {
          output += try outDescPosition.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasCurrentStopSequence {
        output += "\(indent) currentStopSequence: \(currentStopSequence) \n"
      }
      if (hasCurrentStatus) {
        output += "\(indent) currentStatus: \(currentStatus.description)\n"
      }
      if hasTimestamp {
        output += "\(indent) timestamp: \(timestamp) \n"
      }
      if (hasCongestionLevel) {
        output += "\(indent) congestionLevel: \(congestionLevel.description)\n"
      }
      if hasStopId {
        output += "\(indent) stopId: \(stopId) \n"
      }
      if hasVehicle {
        output += "\(indent) vehicle {\n"
        if let outDescVehicle = vehicle {
          output += try outDescVehicle.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if (hasOccupancyStatus) {
        output += "\(indent) occupancyStatus: \(occupancyStatus.description)\n"
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(2000), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasTrip {
                if let hashValuetrip = trip?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuetrip
                }
            }
            if hasPosition {
                if let hashValueposition = position?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueposition
                }
            }
            if hasCurrentStopSequence {
               hashCode = (hashCode &* 31) &+ currentStopSequence.hashValue
            }
            if hasCurrentStatus {
               hashCode = (hashCode &* 31) &+ Int(currentStatus.rawValue)
            }
            if hasTimestamp {
               hashCode = (hashCode &* 31) &+ timestamp.hashValue
            }
            if hasCongestionLevel {
               hashCode = (hashCode &* 31) &+ Int(congestionLevel.rawValue)
            }
            if hasStopId {
               hashCode = (hashCode &* 31) &+ stopId.hashValue
            }
            if hasVehicle {
                if let hashValuevehicle = vehicle?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuevehicle
                }
            }
            if hasOccupancyStatus {
               hashCode = (hashCode &* 31) &+ Int(occupancyStatus.rawValue)
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(2000)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "TransitRealtime.VehiclePosition"
    }
    override public func className() -> String {
        return "TransitRealtime.VehiclePosition"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return TransitRealtime.VehiclePosition.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:TransitRealtime.VehiclePosition = TransitRealtime.VehiclePosition()
      public func getMessage() -> TransitRealtime.VehiclePosition {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasTrip:Bool {
           get {
               return builderResult.hasTrip
           }
      }
      public var trip:TransitRealtime.TripDescriptor! {
           get {
               if tripBuilder_ != nil {
                  builderResult.trip = tripBuilder_.getMessage()
               }
               return builderResult.trip
           }
           set (value) {
               builderResult.hasTrip = true
               builderResult.trip = value
           }
      }
      private var tripBuilder_:TransitRealtime.TripDescriptor.Builder! {
           didSet {
              builderResult.hasTrip = true
           }
      }
      public func getTripBuilder() -> TransitRealtime.TripDescriptor.Builder {
        if tripBuilder_ == nil {
           tripBuilder_ = TransitRealtime.TripDescriptor.Builder()
           builderResult.trip = tripBuilder_.getMessage()
           if trip != nil {
              try! tripBuilder_.mergeFrom(trip)
           }
        }
        return tripBuilder_
      }
      public func setTrip(value:TransitRealtime.TripDescriptor!) -> TransitRealtime.VehiclePosition.Builder {
        self.trip = value
        return self
      }
      public func mergeTrip(value:TransitRealtime.TripDescriptor) throws -> TransitRealtime.VehiclePosition.Builder {
        if builderResult.hasTrip {
          builderResult.trip = try TransitRealtime.TripDescriptor.builderWithPrototype(builderResult.trip).mergeFrom(value).buildPartial()
        } else {
          builderResult.trip = value
        }
        builderResult.hasTrip = true
        return self
      }
      public func clearTrip() -> TransitRealtime.VehiclePosition.Builder {
        tripBuilder_ = nil
        builderResult.hasTrip = false
        builderResult.trip = nil
        return self
      }
      public var hasVehicle:Bool {
           get {
               return builderResult.hasVehicle
           }
      }
      public var vehicle:TransitRealtime.VehicleDescriptor! {
           get {
               if vehicleBuilder_ != nil {
                  builderResult.vehicle = vehicleBuilder_.getMessage()
               }
               return builderResult.vehicle
           }
           set (value) {
               builderResult.hasVehicle = true
               builderResult.vehicle = value
           }
      }
      private var vehicleBuilder_:TransitRealtime.VehicleDescriptor.Builder! {
           didSet {
              builderResult.hasVehicle = true
           }
      }
      public func getVehicleBuilder() -> TransitRealtime.VehicleDescriptor.Builder {
        if vehicleBuilder_ == nil {
           vehicleBuilder_ = TransitRealtime.VehicleDescriptor.Builder()
           builderResult.vehicle = vehicleBuilder_.getMessage()
           if vehicle != nil {
              try! vehicleBuilder_.mergeFrom(vehicle)
           }
        }
        return vehicleBuilder_
      }
      public func setVehicle(value:TransitRealtime.VehicleDescriptor!) -> TransitRealtime.VehiclePosition.Builder {
        self.vehicle = value
        return self
      }
      public func mergeVehicle(value:TransitRealtime.VehicleDescriptor) throws -> TransitRealtime.VehiclePosition.Builder {
        if builderResult.hasVehicle {
          builderResult.vehicle = try TransitRealtime.VehicleDescriptor.builderWithPrototype(builderResult.vehicle).mergeFrom(value).buildPartial()
        } else {
          builderResult.vehicle = value
        }
        builderResult.hasVehicle = true
        return self
      }
      public func clearVehicle() -> TransitRealtime.VehiclePosition.Builder {
        vehicleBuilder_ = nil
        builderResult.hasVehicle = false
        builderResult.vehicle = nil
        return self
      }
      public var hasPosition:Bool {
           get {
               return builderResult.hasPosition
           }
      }
      public var position:TransitRealtime.Position! {
           get {
               if positionBuilder_ != nil {
                  builderResult.position = positionBuilder_.getMessage()
               }
               return builderResult.position
           }
           set (value) {
               builderResult.hasPosition = true
               builderResult.position = value
           }
      }
      private var positionBuilder_:TransitRealtime.Position.Builder! {
           didSet {
              builderResult.hasPosition = true
           }
      }
      public func getPositionBuilder() -> TransitRealtime.Position.Builder {
        if positionBuilder_ == nil {
           positionBuilder_ = TransitRealtime.Position.Builder()
           builderResult.position = positionBuilder_.getMessage()
           if position != nil {
              try! positionBuilder_.mergeFrom(position)
           }
        }
        return positionBuilder_
      }
      public func setPosition(value:TransitRealtime.Position!) -> TransitRealtime.VehiclePosition.Builder {
        self.position = value
        return self
      }
      public func mergePosition(value:TransitRealtime.Position) throws -> TransitRealtime.VehiclePosition.Builder {
        if builderResult.hasPosition {
          builderResult.position = try TransitRealtime.Position.builderWithPrototype(builderResult.position).mergeFrom(value).buildPartial()
        } else {
          builderResult.position = value
        }
        builderResult.hasPosition = true
        return self
      }
      public func clearPosition() -> TransitRealtime.VehiclePosition.Builder {
        positionBuilder_ = nil
        builderResult.hasPosition = false
        builderResult.position = nil
        return self
      }
      public var hasCurrentStopSequence:Bool {
           get {
                return builderResult.hasCurrentStopSequence
           }
      }
      public var currentStopSequence:UInt32 {
           get {
                return builderResult.currentStopSequence
           }
           set (value) {
               builderResult.hasCurrentStopSequence = true
               builderResult.currentStopSequence = value
           }
      }
      public func setCurrentStopSequence(value:UInt32) -> TransitRealtime.VehiclePosition.Builder {
        self.currentStopSequence = value
        return self
      }
      public func clearCurrentStopSequence() -> TransitRealtime.VehiclePosition.Builder{
           builderResult.hasCurrentStopSequence = false
           builderResult.currentStopSequence = UInt32(0)
           return self
      }
      public var hasStopId:Bool {
           get {
                return builderResult.hasStopId
           }
      }
      public var stopId:String {
           get {
                return builderResult.stopId
           }
           set (value) {
               builderResult.hasStopId = true
               builderResult.stopId = value
           }
      }
      public func setStopId(value:String) -> TransitRealtime.VehiclePosition.Builder {
        self.stopId = value
        return self
      }
      public func clearStopId() -> TransitRealtime.VehiclePosition.Builder{
           builderResult.hasStopId = false
           builderResult.stopId = ""
           return self
      }
        public var hasCurrentStatus:Bool{
            get {
                return builderResult.hasCurrentStatus
            }
        }
        public var currentStatus:TransitRealtime.VehiclePosition.VehicleStopStatus {
            get {
                return builderResult.currentStatus
            }
            set (value) {
                builderResult.hasCurrentStatus = true
                builderResult.currentStatus = value
            }
        }
        public func setCurrentStatus(value:TransitRealtime.VehiclePosition.VehicleStopStatus) -> TransitRealtime.VehiclePosition.Builder {
          self.currentStatus = value
          return self
        }
        public func clearCurrentStatus() -> TransitRealtime.VehiclePosition.Builder {
           builderResult.hasCurrentStatus = false
           builderResult.currentStatus = .InTransitTo
           return self
        }
      public var hasTimestamp:Bool {
           get {
                return builderResult.hasTimestamp
           }
      }
      public var timestamp:UInt64 {
           get {
                return builderResult.timestamp
           }
           set (value) {
               builderResult.hasTimestamp = true
               builderResult.timestamp = value
           }
      }
      public func setTimestamp(value:UInt64) -> TransitRealtime.VehiclePosition.Builder {
        self.timestamp = value
        return self
      }
      public func clearTimestamp() -> TransitRealtime.VehiclePosition.Builder{
           builderResult.hasTimestamp = false
           builderResult.timestamp = UInt64(0)
           return self
      }
        public var hasCongestionLevel:Bool{
            get {
                return builderResult.hasCongestionLevel
            }
        }
        public var congestionLevel:TransitRealtime.VehiclePosition.CongestionLevel {
            get {
                return builderResult.congestionLevel
            }
            set (value) {
                builderResult.hasCongestionLevel = true
                builderResult.congestionLevel = value
            }
        }
        public func setCongestionLevel(value:TransitRealtime.VehiclePosition.CongestionLevel) -> TransitRealtime.VehiclePosition.Builder {
          self.congestionLevel = value
          return self
        }
        public func clearCongestionLevel() -> TransitRealtime.VehiclePosition.Builder {
           builderResult.hasCongestionLevel = false
           builderResult.congestionLevel = .UnknownCongestionLevel
           return self
        }
        public var hasOccupancyStatus:Bool{
            get {
                return builderResult.hasOccupancyStatus
            }
        }
        public var occupancyStatus:TransitRealtime.VehiclePosition.OccupancyStatus {
            get {
                return builderResult.occupancyStatus
            }
            set (value) {
                builderResult.hasOccupancyStatus = true
                builderResult.occupancyStatus = value
            }
        }
        public func setOccupancyStatus(value:TransitRealtime.VehiclePosition.OccupancyStatus) -> TransitRealtime.VehiclePosition.Builder {
          self.occupancyStatus = value
          return self
        }
        public func clearOccupancyStatus() -> TransitRealtime.VehiclePosition.Builder {
           builderResult.hasOccupancyStatus = false
           builderResult.occupancyStatus = .Empty
           return self
        }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> TransitRealtime.VehiclePosition.Builder {
        builderResult = TransitRealtime.VehiclePosition()
        return self
      }
      public override func clone() throws -> TransitRealtime.VehiclePosition.Builder {
        return try TransitRealtime.VehiclePosition.builderWithPrototype(builderResult)
      }
      public override func build() throws -> TransitRealtime.VehiclePosition {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> TransitRealtime.VehiclePosition {
        let returnMe:TransitRealtime.VehiclePosition = builderResult
        return returnMe
      }
      public func mergeFrom(other:TransitRealtime.VehiclePosition) throws -> TransitRealtime.VehiclePosition.Builder {
        if other == TransitRealtime.VehiclePosition() {
         return self
        }
        if (other.hasTrip) {
            try mergeTrip(other.trip)
        }
        if (other.hasVehicle) {
            try mergeVehicle(other.vehicle)
        }
        if (other.hasPosition) {
            try mergePosition(other.position)
        }
        if other.hasCurrentStopSequence {
             currentStopSequence = other.currentStopSequence
        }
        if other.hasStopId {
             stopId = other.stopId
        }
        if other.hasCurrentStatus {
             currentStatus = other.currentStatus
        }
        if other.hasTimestamp {
             timestamp = other.timestamp
        }
        if other.hasCongestionLevel {
             congestionLevel = other.congestionLevel
        }
        if other.hasOccupancyStatus {
             occupancyStatus = other.occupancyStatus
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.VehiclePosition.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.VehiclePosition.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            let subBuilder:TransitRealtime.TripDescriptor.Builder = TransitRealtime.TripDescriptor.Builder()
            if hasTrip {
              try subBuilder.mergeFrom(trip)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            trip = subBuilder.buildPartial()

          case 18 :
            let subBuilder:TransitRealtime.Position.Builder = TransitRealtime.Position.Builder()
            if hasPosition {
              try subBuilder.mergeFrom(position)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            position = subBuilder.buildPartial()

          case 24 :
            currentStopSequence = try input.readUInt32()

          case 32 :
            let valueIntcurrentStatus = try input.readEnum()
            if let enumscurrentStatus = TransitRealtime.VehiclePosition.VehicleStopStatus(rawValue:valueIntcurrentStatus){
                 currentStatus = enumscurrentStatus
            } else {
                 try unknownFieldsBuilder.mergeVarintField(4, value:Int64(valueIntcurrentStatus))
            }

          case 40 :
            timestamp = try input.readUInt64()

          case 48 :
            let valueIntcongestionLevel = try input.readEnum()
            if let enumscongestionLevel = TransitRealtime.VehiclePosition.CongestionLevel(rawValue:valueIntcongestionLevel){
                 congestionLevel = enumscongestionLevel
            } else {
                 try unknownFieldsBuilder.mergeVarintField(6, value:Int64(valueIntcongestionLevel))
            }

          case 58 :
            stopId = try input.readString()

          case 66 :
            let subBuilder:TransitRealtime.VehicleDescriptor.Builder = TransitRealtime.VehicleDescriptor.Builder()
            if hasVehicle {
              try subBuilder.mergeFrom(vehicle)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            vehicle = subBuilder.buildPartial()

          case 72 :
            let valueIntoccupancyStatus = try input.readEnum()
            if let enumsoccupancyStatus = TransitRealtime.VehiclePosition.OccupancyStatus(rawValue:valueIntoccupancyStatus){
                 occupancyStatus = enumsoccupancyStatus
            } else {
                 try unknownFieldsBuilder.mergeVarintField(9, value:Int64(valueIntoccupancyStatus))
            }

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  // An alert, indicating some sort of incident in the public transit network.
  final public class Alert : ExtendableMessage, GeneratedMessageProtocol{


      //Enum type declaration start 

      // Cause of this alert.
      public enum Cause:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case UnknownCause = 1

        // Not machine-representable.
        case OtherCause = 2
        case TechnicalProblem = 3

        // Public transit agency employees stopped working.
        case Strike = 4

        // People are blocking the streets.
        case Demonstration = 5
        case Accident = 6
        case Holiday = 7
        case Weather = 8
        case Maintenance = 9
        case Construction = 10
        case PoliceActivity = 11
        case MedicalEmergency = 12

        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .UnknownCause: return ".UnknownCause"
                case .OtherCause: return ".OtherCause"
                case .TechnicalProblem: return ".TechnicalProblem"
                case .Strike: return ".Strike"
                case .Demonstration: return ".Demonstration"
                case .Accident: return ".Accident"
                case .Holiday: return ".Holiday"
                case .Weather: return ".Weather"
                case .Maintenance: return ".Maintenance"
                case .Construction: return ".Construction"
                case .PoliceActivity: return ".PoliceActivity"
                case .MedicalEmergency: return ".MedicalEmergency"
            }
        }
      }

      //Enum type declaration end 



      //Enum type declaration start 

      // What is the effect of this problem on the affected entity.
      public enum Effect:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case NoService = 1
        case ReducedService = 2

        // We don't care about INsignificant delays: they are hard to detect, have
        // little impact on the user, and would clutter the results as they are too
        // frequent.
        case SignificantDelays = 3
        case Detour = 4
        case AdditionalService = 5
        case ModifiedService = 6
        case OtherEffect = 7
        case UnknownEffect = 8
        case StopMoved = 9

        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .NoService: return ".NoService"
                case .ReducedService: return ".ReducedService"
                case .SignificantDelays: return ".SignificantDelays"
                case .Detour: return ".Detour"
                case .AdditionalService: return ".AdditionalService"
                case .ModifiedService: return ".ModifiedService"
                case .OtherEffect: return ".OtherEffect"
                case .UnknownEffect: return ".UnknownEffect"
                case .StopMoved: return ".StopMoved"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var activePeriod:Array<TransitRealtime.TimeRange>  = Array<TransitRealtime.TimeRange>()
    public private(set) var informedEntity:Array<TransitRealtime.EntitySelector>  = Array<TransitRealtime.EntitySelector>()
    public private(set) var cause:TransitRealtime.Alert.Cause = TransitRealtime.Alert.Cause.UnknownCause
    public private(set) var hasCause:Bool = false
    public private(set) var effect:TransitRealtime.Alert.Effect = TransitRealtime.Alert.Effect.UnknownEffect
    public private(set) var hasEffect:Bool = false
    public private(set) var url:TransitRealtime.TranslatedString!
    public private(set) var hasUrl:Bool = false
    public private(set) var headerText:TransitRealtime.TranslatedString!
    public private(set) var hasHeaderText:Bool = false
    public private(set) var descriptionText:TransitRealtime.TranslatedString!
    public private(set) var hasDescriptionText:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitactivePeriod:Bool = true
      for oneElementactivePeriod in activePeriod {
          if (!oneElementactivePeriod.isInitialized()) {
              isInitactivePeriod = false
              break 
          }
      }
      if !isInitactivePeriod {
       return isInitactivePeriod
       }
      var isInitinformedEntity:Bool = true
      for oneElementinformedEntity in informedEntity {
          if (!oneElementinformedEntity.isInitialized()) {
              isInitinformedEntity = false
              break 
          }
      }
      if !isInitinformedEntity {
       return isInitinformedEntity
       }
      if hasUrl {
       if !url.isInitialized() {
         return false
       }
      }
      if hasHeaderText {
       if !headerText.isInitialized() {
         return false
       }
      }
      if hasDescriptionText {
       if !descriptionText.isInitialized() {
         return false
       }
      }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      for oneElementactivePeriod in activePeriod {
          try output.writeMessage(1, value:oneElementactivePeriod)
      }
      for oneElementinformedEntity in informedEntity {
          try output.writeMessage(5, value:oneElementinformedEntity)
      }
      if hasCause {
        try output.writeEnum(6, value:cause.rawValue)
      }
      if hasEffect {
        try output.writeEnum(7, value:effect.rawValue)
      }
      if hasUrl {
        try output.writeMessage(8, value:url)
      }
      if hasHeaderText {
        try output.writeMessage(10, value:headerText)
      }
      if hasDescriptionText {
        try output.writeMessage(11, value:descriptionText)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(2000))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementactivePeriod in activePeriod {
          serialize_size += oneElementactivePeriod.computeMessageSize(1)
      }
      for oneElementinformedEntity in informedEntity {
          serialize_size += oneElementinformedEntity.computeMessageSize(5)
      }
      if (hasCause) {
        serialize_size += cause.rawValue.computeEnumSize(6)
      }
      if (hasEffect) {
        serialize_size += effect.rawValue.computeEnumSize(7)
      }
      if hasUrl {
          if let varSizeurl = url?.computeMessageSize(8) {
              serialize_size += varSizeurl
          }
      }
      if hasHeaderText {
          if let varSizeheaderText = headerText?.computeMessageSize(10) {
              serialize_size += varSizeheaderText
          }
      }
      if hasDescriptionText {
          if let varSizedescriptionText = descriptionText?.computeMessageSize(11) {
              serialize_size += varSizedescriptionText
          }
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TransitRealtime.Alert> {
      var mergedArray = Array<TransitRealtime.Alert>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TransitRealtime.Alert? {
      return try TransitRealtime.Alert.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> TransitRealtime.Alert {
      return try TransitRealtime.Alert.Builder().mergeFromData(data, extensionRegistry:TransitRealtime.GtfsRealtimeProtoTxtRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.Alert {
      return try TransitRealtime.Alert.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> TransitRealtime.Alert {
      return try TransitRealtime.Alert.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.Alert {
      return try TransitRealtime.Alert.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.Alert {
      return try TransitRealtime.Alert.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.Alert {
      return try TransitRealtime.Alert.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> TransitRealtime.Alert.Builder {
      return TransitRealtime.Alert.classBuilder() as! TransitRealtime.Alert.Builder
    }
    public func getBuilder() -> TransitRealtime.Alert.Builder {
      return classBuilder() as! TransitRealtime.Alert.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return TransitRealtime.Alert.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return TransitRealtime.Alert.Builder()
    }
    public func toBuilder() throws -> TransitRealtime.Alert.Builder {
      return try TransitRealtime.Alert.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:TransitRealtime.Alert) throws -> TransitRealtime.Alert.Builder {
      return try TransitRealtime.Alert.Builder().mergeFrom(prototype)
    }
    override public func getDescription(indent:String) throws -> String {
      var output:String = ""
      var activePeriodElementIndex:Int = 0
      for oneElementactivePeriod in activePeriod {
          output += "\(indent) activePeriod[\(activePeriodElementIndex)] {\n"
          output += try oneElementactivePeriod.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          activePeriodElementIndex += 1
      }
      var informedEntityElementIndex:Int = 0
      for oneElementinformedEntity in informedEntity {
          output += "\(indent) informedEntity[\(informedEntityElementIndex)] {\n"
          output += try oneElementinformedEntity.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          informedEntityElementIndex += 1
      }
      if (hasCause) {
        output += "\(indent) cause: \(cause.description)\n"
      }
      if (hasEffect) {
        output += "\(indent) effect: \(effect.description)\n"
      }
      if hasUrl {
        output += "\(indent) url {\n"
        if let outDescUrl = url {
          output += try outDescUrl.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasHeaderText {
        output += "\(indent) headerText {\n"
        if let outDescHeaderText = headerText {
          output += try outDescHeaderText.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasDescriptionText {
        output += "\(indent) descriptionText {\n"
        if let outDescDescriptionText = descriptionText {
          output += try outDescDescriptionText.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(2000), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementactivePeriod in activePeriod {
                hashCode = (hashCode &* 31) &+ oneElementactivePeriod.hashValue
            }
            for oneElementinformedEntity in informedEntity {
                hashCode = (hashCode &* 31) &+ oneElementinformedEntity.hashValue
            }
            if hasCause {
               hashCode = (hashCode &* 31) &+ Int(cause.rawValue)
            }
            if hasEffect {
               hashCode = (hashCode &* 31) &+ Int(effect.rawValue)
            }
            if hasUrl {
                if let hashValueurl = url?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueurl
                }
            }
            if hasHeaderText {
                if let hashValueheaderText = headerText?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueheaderText
                }
            }
            if hasDescriptionText {
                if let hashValuedescriptionText = descriptionText?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuedescriptionText
                }
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(2000)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "TransitRealtime.Alert"
    }
    override public func className() -> String {
        return "TransitRealtime.Alert"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return TransitRealtime.Alert.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:TransitRealtime.Alert = TransitRealtime.Alert()
      public func getMessage() -> TransitRealtime.Alert {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var activePeriod:Array<TransitRealtime.TimeRange> {
           get {
               return builderResult.activePeriod
           }
           set (value) {
               builderResult.activePeriod = value
           }
      }
      public func setActivePeriod(value:Array<TransitRealtime.TimeRange>) -> TransitRealtime.Alert.Builder {
        self.activePeriod = value
        return self
      }
      public func clearActivePeriod() -> TransitRealtime.Alert.Builder {
        builderResult.activePeriod.removeAll(keepCapacity: false)
        return self
      }
      public var informedEntity:Array<TransitRealtime.EntitySelector> {
           get {
               return builderResult.informedEntity
           }
           set (value) {
               builderResult.informedEntity = value
           }
      }
      public func setInformedEntity(value:Array<TransitRealtime.EntitySelector>) -> TransitRealtime.Alert.Builder {
        self.informedEntity = value
        return self
      }
      public func clearInformedEntity() -> TransitRealtime.Alert.Builder {
        builderResult.informedEntity.removeAll(keepCapacity: false)
        return self
      }
        public var hasCause:Bool{
            get {
                return builderResult.hasCause
            }
        }
        public var cause:TransitRealtime.Alert.Cause {
            get {
                return builderResult.cause
            }
            set (value) {
                builderResult.hasCause = true
                builderResult.cause = value
            }
        }
        public func setCause(value:TransitRealtime.Alert.Cause) -> TransitRealtime.Alert.Builder {
          self.cause = value
          return self
        }
        public func clearCause() -> TransitRealtime.Alert.Builder {
           builderResult.hasCause = false
           builderResult.cause = .UnknownCause
           return self
        }
        public var hasEffect:Bool{
            get {
                return builderResult.hasEffect
            }
        }
        public var effect:TransitRealtime.Alert.Effect {
            get {
                return builderResult.effect
            }
            set (value) {
                builderResult.hasEffect = true
                builderResult.effect = value
            }
        }
        public func setEffect(value:TransitRealtime.Alert.Effect) -> TransitRealtime.Alert.Builder {
          self.effect = value
          return self
        }
        public func clearEffect() -> TransitRealtime.Alert.Builder {
           builderResult.hasEffect = false
           builderResult.effect = .UnknownEffect
           return self
        }
      public var hasUrl:Bool {
           get {
               return builderResult.hasUrl
           }
      }
      public var url:TransitRealtime.TranslatedString! {
           get {
               if urlBuilder_ != nil {
                  builderResult.url = urlBuilder_.getMessage()
               }
               return builderResult.url
           }
           set (value) {
               builderResult.hasUrl = true
               builderResult.url = value
           }
      }
      private var urlBuilder_:TransitRealtime.TranslatedString.Builder! {
           didSet {
              builderResult.hasUrl = true
           }
      }
      public func getUrlBuilder() -> TransitRealtime.TranslatedString.Builder {
        if urlBuilder_ == nil {
           urlBuilder_ = TransitRealtime.TranslatedString.Builder()
           builderResult.url = urlBuilder_.getMessage()
           if url != nil {
              try! urlBuilder_.mergeFrom(url)
           }
        }
        return urlBuilder_
      }
      public func setUrl(value:TransitRealtime.TranslatedString!) -> TransitRealtime.Alert.Builder {
        self.url = value
        return self
      }
      public func mergeUrl(value:TransitRealtime.TranslatedString) throws -> TransitRealtime.Alert.Builder {
        if builderResult.hasUrl {
          builderResult.url = try TransitRealtime.TranslatedString.builderWithPrototype(builderResult.url).mergeFrom(value).buildPartial()
        } else {
          builderResult.url = value
        }
        builderResult.hasUrl = true
        return self
      }
      public func clearUrl() -> TransitRealtime.Alert.Builder {
        urlBuilder_ = nil
        builderResult.hasUrl = false
        builderResult.url = nil
        return self
      }
      public var hasHeaderText:Bool {
           get {
               return builderResult.hasHeaderText
           }
      }
      public var headerText:TransitRealtime.TranslatedString! {
           get {
               if headerTextBuilder_ != nil {
                  builderResult.headerText = headerTextBuilder_.getMessage()
               }
               return builderResult.headerText
           }
           set (value) {
               builderResult.hasHeaderText = true
               builderResult.headerText = value
           }
      }
      private var headerTextBuilder_:TransitRealtime.TranslatedString.Builder! {
           didSet {
              builderResult.hasHeaderText = true
           }
      }
      public func getHeaderTextBuilder() -> TransitRealtime.TranslatedString.Builder {
        if headerTextBuilder_ == nil {
           headerTextBuilder_ = TransitRealtime.TranslatedString.Builder()
           builderResult.headerText = headerTextBuilder_.getMessage()
           if headerText != nil {
              try! headerTextBuilder_.mergeFrom(headerText)
           }
        }
        return headerTextBuilder_
      }
      public func setHeaderText(value:TransitRealtime.TranslatedString!) -> TransitRealtime.Alert.Builder {
        self.headerText = value
        return self
      }
      public func mergeHeaderText(value:TransitRealtime.TranslatedString) throws -> TransitRealtime.Alert.Builder {
        if builderResult.hasHeaderText {
          builderResult.headerText = try TransitRealtime.TranslatedString.builderWithPrototype(builderResult.headerText).mergeFrom(value).buildPartial()
        } else {
          builderResult.headerText = value
        }
        builderResult.hasHeaderText = true
        return self
      }
      public func clearHeaderText() -> TransitRealtime.Alert.Builder {
        headerTextBuilder_ = nil
        builderResult.hasHeaderText = false
        builderResult.headerText = nil
        return self
      }
      public var hasDescriptionText:Bool {
           get {
               return builderResult.hasDescriptionText
           }
      }
      public var descriptionText:TransitRealtime.TranslatedString! {
           get {
               if descriptionTextBuilder_ != nil {
                  builderResult.descriptionText = descriptionTextBuilder_.getMessage()
               }
               return builderResult.descriptionText
           }
           set (value) {
               builderResult.hasDescriptionText = true
               builderResult.descriptionText = value
           }
      }
      private var descriptionTextBuilder_:TransitRealtime.TranslatedString.Builder! {
           didSet {
              builderResult.hasDescriptionText = true
           }
      }
      public func getDescriptionTextBuilder() -> TransitRealtime.TranslatedString.Builder {
        if descriptionTextBuilder_ == nil {
           descriptionTextBuilder_ = TransitRealtime.TranslatedString.Builder()
           builderResult.descriptionText = descriptionTextBuilder_.getMessage()
           if descriptionText != nil {
              try! descriptionTextBuilder_.mergeFrom(descriptionText)
           }
        }
        return descriptionTextBuilder_
      }
      public func setDescriptionText(value:TransitRealtime.TranslatedString!) -> TransitRealtime.Alert.Builder {
        self.descriptionText = value
        return self
      }
      public func mergeDescriptionText(value:TransitRealtime.TranslatedString) throws -> TransitRealtime.Alert.Builder {
        if builderResult.hasDescriptionText {
          builderResult.descriptionText = try TransitRealtime.TranslatedString.builderWithPrototype(builderResult.descriptionText).mergeFrom(value).buildPartial()
        } else {
          builderResult.descriptionText = value
        }
        builderResult.hasDescriptionText = true
        return self
      }
      public func clearDescriptionText() -> TransitRealtime.Alert.Builder {
        descriptionTextBuilder_ = nil
        builderResult.hasDescriptionText = false
        builderResult.descriptionText = nil
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> TransitRealtime.Alert.Builder {
        builderResult = TransitRealtime.Alert()
        return self
      }
      public override func clone() throws -> TransitRealtime.Alert.Builder {
        return try TransitRealtime.Alert.builderWithPrototype(builderResult)
      }
      public override func build() throws -> TransitRealtime.Alert {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> TransitRealtime.Alert {
        let returnMe:TransitRealtime.Alert = builderResult
        return returnMe
      }
      public func mergeFrom(other:TransitRealtime.Alert) throws -> TransitRealtime.Alert.Builder {
        if other == TransitRealtime.Alert() {
         return self
        }
        if !other.activePeriod.isEmpty  {
           builderResult.activePeriod += other.activePeriod
        }
        if !other.informedEntity.isEmpty  {
           builderResult.informedEntity += other.informedEntity
        }
        if other.hasCause {
             cause = other.cause
        }
        if other.hasEffect {
             effect = other.effect
        }
        if (other.hasUrl) {
            try mergeUrl(other.url)
        }
        if (other.hasHeaderText) {
            try mergeHeaderText(other.headerText)
        }
        if (other.hasDescriptionText) {
            try mergeDescriptionText(other.descriptionText)
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.Alert.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.Alert.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            let subBuilder = TransitRealtime.TimeRange.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            activePeriod += [subBuilder.buildPartial()]

          case 42 :
            let subBuilder = TransitRealtime.EntitySelector.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            informedEntity += [subBuilder.buildPartial()]

          case 48 :
            let valueIntcause = try input.readEnum()
            if let enumscause = TransitRealtime.Alert.Cause(rawValue:valueIntcause){
                 cause = enumscause
            } else {
                 try unknownFieldsBuilder.mergeVarintField(6, value:Int64(valueIntcause))
            }

          case 56 :
            let valueInteffect = try input.readEnum()
            if let enumseffect = TransitRealtime.Alert.Effect(rawValue:valueInteffect){
                 effect = enumseffect
            } else {
                 try unknownFieldsBuilder.mergeVarintField(7, value:Int64(valueInteffect))
            }

          case 66 :
            let subBuilder:TransitRealtime.TranslatedString.Builder = TransitRealtime.TranslatedString.Builder()
            if hasUrl {
              try subBuilder.mergeFrom(url)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            url = subBuilder.buildPartial()

          case 82 :
            let subBuilder:TransitRealtime.TranslatedString.Builder = TransitRealtime.TranslatedString.Builder()
            if hasHeaderText {
              try subBuilder.mergeFrom(headerText)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            headerText = subBuilder.buildPartial()

          case 90 :
            let subBuilder:TransitRealtime.TranslatedString.Builder = TransitRealtime.TranslatedString.Builder()
            if hasDescriptionText {
              try subBuilder.mergeFrom(descriptionText)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            descriptionText = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  // A time interval. The interval is considered active at time 't' if 't' is
  // greater than or equal to the start time and less than the end time.
  final public class TimeRange : ExtendableMessage, GeneratedMessageProtocol{
    // Start time, in POSIX time (i.e., number of seconds since January 1st 1970
    // 00:00:00 UTC).
    // If missing, the interval starts at minus infinity.
    public private(set) var start:UInt64 = UInt64(0)

    public private(set) var hasStart:Bool = false
    // End time, in POSIX time (i.e., number of seconds since January 1st 1970
    // 00:00:00 UTC).
    // If missing, the interval ends at plus infinity.
    public private(set) var end:UInt64 = UInt64(0)

    public private(set) var hasEnd:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasStart {
        try output.writeUInt64(1, value:start)
      }
      if hasEnd {
        try output.writeUInt64(2, value:end)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(2000))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasStart {
        serialize_size += start.computeUInt64Size(1)
      }
      if hasEnd {
        serialize_size += end.computeUInt64Size(2)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TransitRealtime.TimeRange> {
      var mergedArray = Array<TransitRealtime.TimeRange>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TransitRealtime.TimeRange? {
      return try TransitRealtime.TimeRange.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> TransitRealtime.TimeRange {
      return try TransitRealtime.TimeRange.Builder().mergeFromData(data, extensionRegistry:TransitRealtime.GtfsRealtimeProtoTxtRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TimeRange {
      return try TransitRealtime.TimeRange.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> TransitRealtime.TimeRange {
      return try TransitRealtime.TimeRange.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TimeRange {
      return try TransitRealtime.TimeRange.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.TimeRange {
      return try TransitRealtime.TimeRange.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TimeRange {
      return try TransitRealtime.TimeRange.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> TransitRealtime.TimeRange.Builder {
      return TransitRealtime.TimeRange.classBuilder() as! TransitRealtime.TimeRange.Builder
    }
    public func getBuilder() -> TransitRealtime.TimeRange.Builder {
      return classBuilder() as! TransitRealtime.TimeRange.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return TransitRealtime.TimeRange.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return TransitRealtime.TimeRange.Builder()
    }
    public func toBuilder() throws -> TransitRealtime.TimeRange.Builder {
      return try TransitRealtime.TimeRange.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:TransitRealtime.TimeRange) throws -> TransitRealtime.TimeRange.Builder {
      return try TransitRealtime.TimeRange.Builder().mergeFrom(prototype)
    }
    override public func getDescription(indent:String) throws -> String {
      var output:String = ""
      if hasStart {
        output += "\(indent) start: \(start) \n"
      }
      if hasEnd {
        output += "\(indent) end: \(end) \n"
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(2000), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasStart {
               hashCode = (hashCode &* 31) &+ start.hashValue
            }
            if hasEnd {
               hashCode = (hashCode &* 31) &+ end.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(2000)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "TransitRealtime.TimeRange"
    }
    override public func className() -> String {
        return "TransitRealtime.TimeRange"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return TransitRealtime.TimeRange.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:TransitRealtime.TimeRange = TransitRealtime.TimeRange()
      public func getMessage() -> TransitRealtime.TimeRange {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasStart:Bool {
           get {
                return builderResult.hasStart
           }
      }
      public var start:UInt64 {
           get {
                return builderResult.start
           }
           set (value) {
               builderResult.hasStart = true
               builderResult.start = value
           }
      }
      public func setStart(value:UInt64) -> TransitRealtime.TimeRange.Builder {
        self.start = value
        return self
      }
      public func clearStart() -> TransitRealtime.TimeRange.Builder{
           builderResult.hasStart = false
           builderResult.start = UInt64(0)
           return self
      }
      public var hasEnd:Bool {
           get {
                return builderResult.hasEnd
           }
      }
      public var end:UInt64 {
           get {
                return builderResult.end
           }
           set (value) {
               builderResult.hasEnd = true
               builderResult.end = value
           }
      }
      public func setEnd(value:UInt64) -> TransitRealtime.TimeRange.Builder {
        self.end = value
        return self
      }
      public func clearEnd() -> TransitRealtime.TimeRange.Builder{
           builderResult.hasEnd = false
           builderResult.end = UInt64(0)
           return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> TransitRealtime.TimeRange.Builder {
        builderResult = TransitRealtime.TimeRange()
        return self
      }
      public override func clone() throws -> TransitRealtime.TimeRange.Builder {
        return try TransitRealtime.TimeRange.builderWithPrototype(builderResult)
      }
      public override func build() throws -> TransitRealtime.TimeRange {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> TransitRealtime.TimeRange {
        let returnMe:TransitRealtime.TimeRange = builderResult
        return returnMe
      }
      public func mergeFrom(other:TransitRealtime.TimeRange) throws -> TransitRealtime.TimeRange.Builder {
        if other == TransitRealtime.TimeRange() {
         return self
        }
        if other.hasStart {
             start = other.start
        }
        if other.hasEnd {
             end = other.end
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.TimeRange.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TimeRange.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            start = try input.readUInt64()

          case 16 :
            end = try input.readUInt64()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  // A position.
  final public class Position : ExtendableMessage, GeneratedMessageProtocol{
    // Degrees North, in the WGS-84 coordinate system.
    public private(set) var latitude:Float = Float(0)

    public private(set) var hasLatitude:Bool = false
    // Degrees East, in the WGS-84 coordinate system.
    public private(set) var longitude:Float = Float(0)

    public private(set) var hasLongitude:Bool = false
    // Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
    // This can be the compass bearing, or the direction towards the next stop
    // or intermediate location.
    // This should not be direction deduced from the sequence of previous
    // positions, which can be computed from previous data.
    public private(set) var bearing:Float = Float(0)

    public private(set) var hasBearing:Bool = false
    // Odometer value, in meters.
    public private(set) var odometer:Double = Double(0)

    public private(set) var hasOdometer:Bool = false
    // Momentary speed measured by the vehicle, in meters per second.
    public private(set) var speed:Float = Float(0)

    public private(set) var hasSpeed:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !hasLatitude {
        return false
      }
      if !hasLongitude {
        return false
      }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasLatitude {
        try output.writeFloat(1, value:latitude)
      }
      if hasLongitude {
        try output.writeFloat(2, value:longitude)
      }
      if hasBearing {
        try output.writeFloat(3, value:bearing)
      }
      if hasOdometer {
        try output.writeDouble(4, value:odometer)
      }
      if hasSpeed {
        try output.writeFloat(5, value:speed)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(2000))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasLatitude {
        serialize_size += latitude.computeFloatSize(1)
      }
      if hasLongitude {
        serialize_size += longitude.computeFloatSize(2)
      }
      if hasBearing {
        serialize_size += bearing.computeFloatSize(3)
      }
      if hasOdometer {
        serialize_size += odometer.computeDoubleSize(4)
      }
      if hasSpeed {
        serialize_size += speed.computeFloatSize(5)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TransitRealtime.Position> {
      var mergedArray = Array<TransitRealtime.Position>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TransitRealtime.Position? {
      return try TransitRealtime.Position.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> TransitRealtime.Position {
      return try TransitRealtime.Position.Builder().mergeFromData(data, extensionRegistry:TransitRealtime.GtfsRealtimeProtoTxtRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.Position {
      return try TransitRealtime.Position.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> TransitRealtime.Position {
      return try TransitRealtime.Position.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.Position {
      return try TransitRealtime.Position.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.Position {
      return try TransitRealtime.Position.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.Position {
      return try TransitRealtime.Position.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> TransitRealtime.Position.Builder {
      return TransitRealtime.Position.classBuilder() as! TransitRealtime.Position.Builder
    }
    public func getBuilder() -> TransitRealtime.Position.Builder {
      return classBuilder() as! TransitRealtime.Position.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return TransitRealtime.Position.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return TransitRealtime.Position.Builder()
    }
    public func toBuilder() throws -> TransitRealtime.Position.Builder {
      return try TransitRealtime.Position.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:TransitRealtime.Position) throws -> TransitRealtime.Position.Builder {
      return try TransitRealtime.Position.Builder().mergeFrom(prototype)
    }
    override public func getDescription(indent:String) throws -> String {
      var output:String = ""
      if hasLatitude {
        output += "\(indent) latitude: \(latitude) \n"
      }
      if hasLongitude {
        output += "\(indent) longitude: \(longitude) \n"
      }
      if hasBearing {
        output += "\(indent) bearing: \(bearing) \n"
      }
      if hasOdometer {
        output += "\(indent) odometer: \(odometer) \n"
      }
      if hasSpeed {
        output += "\(indent) speed: \(speed) \n"
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(2000), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasLatitude {
               hashCode = (hashCode &* 31) &+ latitude.hashValue
            }
            if hasLongitude {
               hashCode = (hashCode &* 31) &+ longitude.hashValue
            }
            if hasBearing {
               hashCode = (hashCode &* 31) &+ bearing.hashValue
            }
            if hasOdometer {
               hashCode = (hashCode &* 31) &+ odometer.hashValue
            }
            if hasSpeed {
               hashCode = (hashCode &* 31) &+ speed.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(2000)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "TransitRealtime.Position"
    }
    override public func className() -> String {
        return "TransitRealtime.Position"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return TransitRealtime.Position.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:TransitRealtime.Position = TransitRealtime.Position()
      public func getMessage() -> TransitRealtime.Position {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasLatitude:Bool {
           get {
                return builderResult.hasLatitude
           }
      }
      public var latitude:Float {
           get {
                return builderResult.latitude
           }
           set (value) {
               builderResult.hasLatitude = true
               builderResult.latitude = value
           }
      }
      public func setLatitude(value:Float) -> TransitRealtime.Position.Builder {
        self.latitude = value
        return self
      }
      public func clearLatitude() -> TransitRealtime.Position.Builder{
           builderResult.hasLatitude = false
           builderResult.latitude = Float(0)
           return self
      }
      public var hasLongitude:Bool {
           get {
                return builderResult.hasLongitude
           }
      }
      public var longitude:Float {
           get {
                return builderResult.longitude
           }
           set (value) {
               builderResult.hasLongitude = true
               builderResult.longitude = value
           }
      }
      public func setLongitude(value:Float) -> TransitRealtime.Position.Builder {
        self.longitude = value
        return self
      }
      public func clearLongitude() -> TransitRealtime.Position.Builder{
           builderResult.hasLongitude = false
           builderResult.longitude = Float(0)
           return self
      }
      public var hasBearing:Bool {
           get {
                return builderResult.hasBearing
           }
      }
      public var bearing:Float {
           get {
                return builderResult.bearing
           }
           set (value) {
               builderResult.hasBearing = true
               builderResult.bearing = value
           }
      }
      public func setBearing(value:Float) -> TransitRealtime.Position.Builder {
        self.bearing = value
        return self
      }
      public func clearBearing() -> TransitRealtime.Position.Builder{
           builderResult.hasBearing = false
           builderResult.bearing = Float(0)
           return self
      }
      public var hasOdometer:Bool {
           get {
                return builderResult.hasOdometer
           }
      }
      public var odometer:Double {
           get {
                return builderResult.odometer
           }
           set (value) {
               builderResult.hasOdometer = true
               builderResult.odometer = value
           }
      }
      public func setOdometer(value:Double) -> TransitRealtime.Position.Builder {
        self.odometer = value
        return self
      }
      public func clearOdometer() -> TransitRealtime.Position.Builder{
           builderResult.hasOdometer = false
           builderResult.odometer = Double(0)
           return self
      }
      public var hasSpeed:Bool {
           get {
                return builderResult.hasSpeed
           }
      }
      public var speed:Float {
           get {
                return builderResult.speed
           }
           set (value) {
               builderResult.hasSpeed = true
               builderResult.speed = value
           }
      }
      public func setSpeed(value:Float) -> TransitRealtime.Position.Builder {
        self.speed = value
        return self
      }
      public func clearSpeed() -> TransitRealtime.Position.Builder{
           builderResult.hasSpeed = false
           builderResult.speed = Float(0)
           return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> TransitRealtime.Position.Builder {
        builderResult = TransitRealtime.Position()
        return self
      }
      public override func clone() throws -> TransitRealtime.Position.Builder {
        return try TransitRealtime.Position.builderWithPrototype(builderResult)
      }
      public override func build() throws -> TransitRealtime.Position {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> TransitRealtime.Position {
        let returnMe:TransitRealtime.Position = builderResult
        return returnMe
      }
      public func mergeFrom(other:TransitRealtime.Position) throws -> TransitRealtime.Position.Builder {
        if other == TransitRealtime.Position() {
         return self
        }
        if other.hasLatitude {
             latitude = other.latitude
        }
        if other.hasLongitude {
             longitude = other.longitude
        }
        if other.hasBearing {
             bearing = other.bearing
        }
        if other.hasOdometer {
             odometer = other.odometer
        }
        if other.hasSpeed {
             speed = other.speed
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.Position.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.Position.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 13 :
            latitude = try input.readFloat()

          case 21 :
            longitude = try input.readFloat()

          case 29 :
            bearing = try input.readFloat()

          case 33 :
            odometer = try input.readDouble()

          case 45 :
            speed = try input.readFloat()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  // A descriptor that identifies an instance of a GTFS trip, or all instances of
  // a trip along a route.
  // - To specify a single trip instance, the trip_id (and if necessary,
  //   start_time) is set. If route_id is also set, then it should be same as one
  //   that the given trip corresponds to.
  // - To specify all the trips along a given route, only the route_id should be
  //   set. Note that if the trip_id is not known, then stop sequence ids in
  //   TripUpdate are not sufficient, and stop_ids must be provided as well. In
  //   addition, absolute arrival/departure times must be provided.
  final public class TripDescriptor : ExtendableMessage, GeneratedMessageProtocol{


      //Enum type declaration start 

      // The relation between this trip and the static schedule. If a trip is done
      // in accordance with temporary schedule, not reflected in GTFS, then it
      // shouldn't be marked as SCHEDULED, but likely as ADDED.
      public enum ScheduleRelationship:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        // Trip that is running in accordance with its GTFS schedule, or is close
        // enough to the scheduled trip to be associated with it.
        case Scheduled = 0

        // An extra trip that was added in addition to a running schedule, for
        // example, to replace a broken vehicle or to respond to sudden passenger
        // load.
        case Added = 1

        // A trip that is running with no schedule associated to it, for example, if
        // there is no schedule at all.
        case Unscheduled = 2

        // A trip that existed in the schedule but was removed.
        case Canceled = 3

        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Scheduled: return ".Scheduled"
                case .Added: return ".Added"
                case .Unscheduled: return ".Unscheduled"
                case .Canceled: return ".Canceled"
            }
        }
      }

      //Enum type declaration end 

    // The trip_id from the GTFS feed that this selector refers to.
    // For non frequency-based trips, this field is enough to uniquely identify
    // the trip. For frequency-based trip, start_time and start_date might also be
    // necessary.
    public private(set) var tripId:String = ""

    public private(set) var hasTripId:Bool = false
    // The route_id from the GTFS that this selector refers to.
    public private(set) var routeId:String = ""

    public private(set) var hasRouteId:Bool = false
    // The direction_id from the GTFS feed trips.txt file, indicating the
    // direction of travel for trips this selector refers to. This field is
    // still experimental, and subject to change. It may be formally adopted in
    // the future.
    public private(set) var directionId:UInt32 = UInt32(0)

    public private(set) var hasDirectionId:Bool = false
    // The initially scheduled start time of this trip instance.
    // When the trip_id corresponds to a non-frequency-based trip, this field
    // should either be omitted or be equal to the value in the GTFS feed. When
    // the trip_id correponds to a frequency-based trip, the start_time must be
    // specified for trip updates and vehicle positions. If the trip corresponds
    // to exact_times=1 GTFS record, then start_time must be some multiple
    // (including zero) of headway_secs later than frequencies.txt start_time for
    // the corresponding time period. If the trip corresponds to exact_times=0,
    // then its start_time may be arbitrary, and is initially expected to be the
    // first departure of the trip. Once established, the start_time of this
    // frequency-based trip should be considered immutable, even if the first
    // departure time changes -- that time change may instead be reflected in a
    // StopTimeUpdate.
    // Format and semantics of the field is same as that of
    // GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
    public private(set) var startTime:String = ""

    public private(set) var hasStartTime:Bool = false
    // The scheduled start date of this trip instance.
    // Must be provided to disambiguate trips that are so late as to collide with
    // a scheduled trip on a next day. For example, for a train that departs 8:00
    // and 20:00 every day, and is 12 hours late, there would be two distinct
    // trips on the same time.
    // This field can be provided but is not mandatory for schedules in which such
    // collisions are impossible - for example, a service running on hourly
    // schedule where a vehicle that is one hour late is not considered to be
    // related to schedule anymore.
    // In YYYYMMDD format.
    public private(set) var startDate:String = ""

    public private(set) var hasStartDate:Bool = false
    public private(set) var scheduleRelationship:TransitRealtime.TripDescriptor.ScheduleRelationship = TransitRealtime.TripDescriptor.ScheduleRelationship.Scheduled
    public private(set) var hasScheduleRelationship:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasTripId {
        try output.writeString(1, value:tripId)
      }
      if hasStartTime {
        try output.writeString(2, value:startTime)
      }
      if hasStartDate {
        try output.writeString(3, value:startDate)
      }
      if hasScheduleRelationship {
        try output.writeEnum(4, value:scheduleRelationship.rawValue)
      }
      if hasRouteId {
        try output.writeString(5, value:routeId)
      }
      if hasDirectionId {
        try output.writeUInt32(6, value:directionId)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(2000))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasTripId {
        serialize_size += tripId.computeStringSize(1)
      }
      if hasStartTime {
        serialize_size += startTime.computeStringSize(2)
      }
      if hasStartDate {
        serialize_size += startDate.computeStringSize(3)
      }
      if (hasScheduleRelationship) {
        serialize_size += scheduleRelationship.rawValue.computeEnumSize(4)
      }
      if hasRouteId {
        serialize_size += routeId.computeStringSize(5)
      }
      if hasDirectionId {
        serialize_size += directionId.computeUInt32Size(6)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TransitRealtime.TripDescriptor> {
      var mergedArray = Array<TransitRealtime.TripDescriptor>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TransitRealtime.TripDescriptor? {
      return try TransitRealtime.TripDescriptor.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> TransitRealtime.TripDescriptor {
      return try TransitRealtime.TripDescriptor.Builder().mergeFromData(data, extensionRegistry:TransitRealtime.GtfsRealtimeProtoTxtRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripDescriptor {
      return try TransitRealtime.TripDescriptor.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> TransitRealtime.TripDescriptor {
      return try TransitRealtime.TripDescriptor.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripDescriptor {
      return try TransitRealtime.TripDescriptor.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.TripDescriptor {
      return try TransitRealtime.TripDescriptor.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripDescriptor {
      return try TransitRealtime.TripDescriptor.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> TransitRealtime.TripDescriptor.Builder {
      return TransitRealtime.TripDescriptor.classBuilder() as! TransitRealtime.TripDescriptor.Builder
    }
    public func getBuilder() -> TransitRealtime.TripDescriptor.Builder {
      return classBuilder() as! TransitRealtime.TripDescriptor.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return TransitRealtime.TripDescriptor.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return TransitRealtime.TripDescriptor.Builder()
    }
    public func toBuilder() throws -> TransitRealtime.TripDescriptor.Builder {
      return try TransitRealtime.TripDescriptor.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:TransitRealtime.TripDescriptor) throws -> TransitRealtime.TripDescriptor.Builder {
      return try TransitRealtime.TripDescriptor.Builder().mergeFrom(prototype)
    }
    override public func getDescription(indent:String) throws -> String {
      var output:String = ""
      if hasTripId {
        output += "\(indent) tripId: \(tripId) \n"
      }
      if hasStartTime {
        output += "\(indent) startTime: \(startTime) \n"
      }
      if hasStartDate {
        output += "\(indent) startDate: \(startDate) \n"
      }
      if (hasScheduleRelationship) {
        output += "\(indent) scheduleRelationship: \(scheduleRelationship.description)\n"
      }
      if hasRouteId {
        output += "\(indent) routeId: \(routeId) \n"
      }
      if hasDirectionId {
        output += "\(indent) directionId: \(directionId) \n"
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(2000), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasTripId {
               hashCode = (hashCode &* 31) &+ tripId.hashValue
            }
            if hasStartTime {
               hashCode = (hashCode &* 31) &+ startTime.hashValue
            }
            if hasStartDate {
               hashCode = (hashCode &* 31) &+ startDate.hashValue
            }
            if hasScheduleRelationship {
               hashCode = (hashCode &* 31) &+ Int(scheduleRelationship.rawValue)
            }
            if hasRouteId {
               hashCode = (hashCode &* 31) &+ routeId.hashValue
            }
            if hasDirectionId {
               hashCode = (hashCode &* 31) &+ directionId.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(2000)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "TransitRealtime.TripDescriptor"
    }
    override public func className() -> String {
        return "TransitRealtime.TripDescriptor"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return TransitRealtime.TripDescriptor.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:TransitRealtime.TripDescriptor = TransitRealtime.TripDescriptor()
      public func getMessage() -> TransitRealtime.TripDescriptor {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasTripId:Bool {
           get {
                return builderResult.hasTripId
           }
      }
      public var tripId:String {
           get {
                return builderResult.tripId
           }
           set (value) {
               builderResult.hasTripId = true
               builderResult.tripId = value
           }
      }
      public func setTripId(value:String) -> TransitRealtime.TripDescriptor.Builder {
        self.tripId = value
        return self
      }
      public func clearTripId() -> TransitRealtime.TripDescriptor.Builder{
           builderResult.hasTripId = false
           builderResult.tripId = ""
           return self
      }
      public var hasRouteId:Bool {
           get {
                return builderResult.hasRouteId
           }
      }
      public var routeId:String {
           get {
                return builderResult.routeId
           }
           set (value) {
               builderResult.hasRouteId = true
               builderResult.routeId = value
           }
      }
      public func setRouteId(value:String) -> TransitRealtime.TripDescriptor.Builder {
        self.routeId = value
        return self
      }
      public func clearRouteId() -> TransitRealtime.TripDescriptor.Builder{
           builderResult.hasRouteId = false
           builderResult.routeId = ""
           return self
      }
      public var hasDirectionId:Bool {
           get {
                return builderResult.hasDirectionId
           }
      }
      public var directionId:UInt32 {
           get {
                return builderResult.directionId
           }
           set (value) {
               builderResult.hasDirectionId = true
               builderResult.directionId = value
           }
      }
      public func setDirectionId(value:UInt32) -> TransitRealtime.TripDescriptor.Builder {
        self.directionId = value
        return self
      }
      public func clearDirectionId() -> TransitRealtime.TripDescriptor.Builder{
           builderResult.hasDirectionId = false
           builderResult.directionId = UInt32(0)
           return self
      }
      public var hasStartTime:Bool {
           get {
                return builderResult.hasStartTime
           }
      }
      public var startTime:String {
           get {
                return builderResult.startTime
           }
           set (value) {
               builderResult.hasStartTime = true
               builderResult.startTime = value
           }
      }
      public func setStartTime(value:String) -> TransitRealtime.TripDescriptor.Builder {
        self.startTime = value
        return self
      }
      public func clearStartTime() -> TransitRealtime.TripDescriptor.Builder{
           builderResult.hasStartTime = false
           builderResult.startTime = ""
           return self
      }
      public var hasStartDate:Bool {
           get {
                return builderResult.hasStartDate
           }
      }
      public var startDate:String {
           get {
                return builderResult.startDate
           }
           set (value) {
               builderResult.hasStartDate = true
               builderResult.startDate = value
           }
      }
      public func setStartDate(value:String) -> TransitRealtime.TripDescriptor.Builder {
        self.startDate = value
        return self
      }
      public func clearStartDate() -> TransitRealtime.TripDescriptor.Builder{
           builderResult.hasStartDate = false
           builderResult.startDate = ""
           return self
      }
        public var hasScheduleRelationship:Bool{
            get {
                return builderResult.hasScheduleRelationship
            }
        }
        public var scheduleRelationship:TransitRealtime.TripDescriptor.ScheduleRelationship {
            get {
                return builderResult.scheduleRelationship
            }
            set (value) {
                builderResult.hasScheduleRelationship = true
                builderResult.scheduleRelationship = value
            }
        }
        public func setScheduleRelationship(value:TransitRealtime.TripDescriptor.ScheduleRelationship) -> TransitRealtime.TripDescriptor.Builder {
          self.scheduleRelationship = value
          return self
        }
        public func clearScheduleRelationship() -> TransitRealtime.TripDescriptor.Builder {
           builderResult.hasScheduleRelationship = false
           builderResult.scheduleRelationship = .Scheduled
           return self
        }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> TransitRealtime.TripDescriptor.Builder {
        builderResult = TransitRealtime.TripDescriptor()
        return self
      }
      public override func clone() throws -> TransitRealtime.TripDescriptor.Builder {
        return try TransitRealtime.TripDescriptor.builderWithPrototype(builderResult)
      }
      public override func build() throws -> TransitRealtime.TripDescriptor {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> TransitRealtime.TripDescriptor {
        let returnMe:TransitRealtime.TripDescriptor = builderResult
        return returnMe
      }
      public func mergeFrom(other:TransitRealtime.TripDescriptor) throws -> TransitRealtime.TripDescriptor.Builder {
        if other == TransitRealtime.TripDescriptor() {
         return self
        }
        if other.hasTripId {
             tripId = other.tripId
        }
        if other.hasRouteId {
             routeId = other.routeId
        }
        if other.hasDirectionId {
             directionId = other.directionId
        }
        if other.hasStartTime {
             startTime = other.startTime
        }
        if other.hasStartDate {
             startDate = other.startDate
        }
        if other.hasScheduleRelationship {
             scheduleRelationship = other.scheduleRelationship
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.TripDescriptor.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripDescriptor.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            tripId = try input.readString()

          case 18 :
            startTime = try input.readString()

          case 26 :
            startDate = try input.readString()

          case 32 :
            let valueIntscheduleRelationship = try input.readEnum()
            if let enumsscheduleRelationship = TransitRealtime.TripDescriptor.ScheduleRelationship(rawValue:valueIntscheduleRelationship){
                 scheduleRelationship = enumsscheduleRelationship
            } else {
                 try unknownFieldsBuilder.mergeVarintField(4, value:Int64(valueIntscheduleRelationship))
            }

          case 42 :
            routeId = try input.readString()

          case 48 :
            directionId = try input.readUInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  // Identification information for the vehicle performing the trip.
  final public class VehicleDescriptor : ExtendableMessage, GeneratedMessageProtocol{
    // Internal system identification of the vehicle. Should be unique per
    // vehicle, and can be used for tracking the vehicle as it proceeds through
    // the system.
    public private(set) var id:String = ""

    public private(set) var hasId:Bool = false
    // User visible label, i.e., something that must be shown to the passenger to
    // help identify the correct vehicle.
    public private(set) var label:String = ""

    public private(set) var hasLabel:Bool = false
    // The license plate of the vehicle.
    public private(set) var licensePlate:String = ""

    public private(set) var hasLicensePlate:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasId {
        try output.writeString(1, value:id)
      }
      if hasLabel {
        try output.writeString(2, value:label)
      }
      if hasLicensePlate {
        try output.writeString(3, value:licensePlate)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(2000))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasId {
        serialize_size += id.computeStringSize(1)
      }
      if hasLabel {
        serialize_size += label.computeStringSize(2)
      }
      if hasLicensePlate {
        serialize_size += licensePlate.computeStringSize(3)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TransitRealtime.VehicleDescriptor> {
      var mergedArray = Array<TransitRealtime.VehicleDescriptor>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TransitRealtime.VehicleDescriptor? {
      return try TransitRealtime.VehicleDescriptor.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> TransitRealtime.VehicleDescriptor {
      return try TransitRealtime.VehicleDescriptor.Builder().mergeFromData(data, extensionRegistry:TransitRealtime.GtfsRealtimeProtoTxtRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.VehicleDescriptor {
      return try TransitRealtime.VehicleDescriptor.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> TransitRealtime.VehicleDescriptor {
      return try TransitRealtime.VehicleDescriptor.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.VehicleDescriptor {
      return try TransitRealtime.VehicleDescriptor.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.VehicleDescriptor {
      return try TransitRealtime.VehicleDescriptor.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.VehicleDescriptor {
      return try TransitRealtime.VehicleDescriptor.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> TransitRealtime.VehicleDescriptor.Builder {
      return TransitRealtime.VehicleDescriptor.classBuilder() as! TransitRealtime.VehicleDescriptor.Builder
    }
    public func getBuilder() -> TransitRealtime.VehicleDescriptor.Builder {
      return classBuilder() as! TransitRealtime.VehicleDescriptor.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return TransitRealtime.VehicleDescriptor.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return TransitRealtime.VehicleDescriptor.Builder()
    }
    public func toBuilder() throws -> TransitRealtime.VehicleDescriptor.Builder {
      return try TransitRealtime.VehicleDescriptor.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:TransitRealtime.VehicleDescriptor) throws -> TransitRealtime.VehicleDescriptor.Builder {
      return try TransitRealtime.VehicleDescriptor.Builder().mergeFrom(prototype)
    }
    override public func getDescription(indent:String) throws -> String {
      var output:String = ""
      if hasId {
        output += "\(indent) id: \(id) \n"
      }
      if hasLabel {
        output += "\(indent) label: \(label) \n"
      }
      if hasLicensePlate {
        output += "\(indent) licensePlate: \(licensePlate) \n"
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(2000), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
               hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasLabel {
               hashCode = (hashCode &* 31) &+ label.hashValue
            }
            if hasLicensePlate {
               hashCode = (hashCode &* 31) &+ licensePlate.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(2000)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "TransitRealtime.VehicleDescriptor"
    }
    override public func className() -> String {
        return "TransitRealtime.VehicleDescriptor"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return TransitRealtime.VehicleDescriptor.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:TransitRealtime.VehicleDescriptor = TransitRealtime.VehicleDescriptor()
      public func getMessage() -> TransitRealtime.VehicleDescriptor {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasId:Bool {
           get {
                return builderResult.hasId
           }
      }
      public var id:String {
           get {
                return builderResult.id
           }
           set (value) {
               builderResult.hasId = true
               builderResult.id = value
           }
      }
      public func setId(value:String) -> TransitRealtime.VehicleDescriptor.Builder {
        self.id = value
        return self
      }
      public func clearId() -> TransitRealtime.VehicleDescriptor.Builder{
           builderResult.hasId = false
           builderResult.id = ""
           return self
      }
      public var hasLabel:Bool {
           get {
                return builderResult.hasLabel
           }
      }
      public var label:String {
           get {
                return builderResult.label
           }
           set (value) {
               builderResult.hasLabel = true
               builderResult.label = value
           }
      }
      public func setLabel(value:String) -> TransitRealtime.VehicleDescriptor.Builder {
        self.label = value
        return self
      }
      public func clearLabel() -> TransitRealtime.VehicleDescriptor.Builder{
           builderResult.hasLabel = false
           builderResult.label = ""
           return self
      }
      public var hasLicensePlate:Bool {
           get {
                return builderResult.hasLicensePlate
           }
      }
      public var licensePlate:String {
           get {
                return builderResult.licensePlate
           }
           set (value) {
               builderResult.hasLicensePlate = true
               builderResult.licensePlate = value
           }
      }
      public func setLicensePlate(value:String) -> TransitRealtime.VehicleDescriptor.Builder {
        self.licensePlate = value
        return self
      }
      public func clearLicensePlate() -> TransitRealtime.VehicleDescriptor.Builder{
           builderResult.hasLicensePlate = false
           builderResult.licensePlate = ""
           return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> TransitRealtime.VehicleDescriptor.Builder {
        builderResult = TransitRealtime.VehicleDescriptor()
        return self
      }
      public override func clone() throws -> TransitRealtime.VehicleDescriptor.Builder {
        return try TransitRealtime.VehicleDescriptor.builderWithPrototype(builderResult)
      }
      public override func build() throws -> TransitRealtime.VehicleDescriptor {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> TransitRealtime.VehicleDescriptor {
        let returnMe:TransitRealtime.VehicleDescriptor = builderResult
        return returnMe
      }
      public func mergeFrom(other:TransitRealtime.VehicleDescriptor) throws -> TransitRealtime.VehicleDescriptor.Builder {
        if other == TransitRealtime.VehicleDescriptor() {
         return self
        }
        if other.hasId {
             id = other.id
        }
        if other.hasLabel {
             label = other.label
        }
        if other.hasLicensePlate {
             licensePlate = other.licensePlate
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.VehicleDescriptor.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.VehicleDescriptor.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            id = try input.readString()

          case 18 :
            label = try input.readString()

          case 26 :
            licensePlate = try input.readString()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  // A selector for an entity in a GTFS feed.
  final public class EntitySelector : ExtendableMessage, GeneratedMessageProtocol{
    // The values of the fields should correspond to the appropriate fields in the
    // GTFS feed.
    // At least one specifier must be given. If several are given, then the
    // matching has to apply to all the given specifiers.
    public private(set) var agencyId:String = ""

    public private(set) var hasAgencyId:Bool = false
    public private(set) var routeId:String = ""

    public private(set) var hasRouteId:Bool = false
    // corresponds to route_type in GTFS.
    public private(set) var routeType:Int32 = Int32(0)

    public private(set) var hasRouteType:Bool = false
    public private(set) var trip:TransitRealtime.TripDescriptor!
    public private(set) var hasTrip:Bool = false
    public private(set) var stopId:String = ""

    public private(set) var hasStopId:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasTrip {
       if !trip.isInitialized() {
         return false
       }
      }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasAgencyId {
        try output.writeString(1, value:agencyId)
      }
      if hasRouteId {
        try output.writeString(2, value:routeId)
      }
      if hasRouteType {
        try output.writeInt32(3, value:routeType)
      }
      if hasTrip {
        try output.writeMessage(4, value:trip)
      }
      if hasStopId {
        try output.writeString(5, value:stopId)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(2000))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasAgencyId {
        serialize_size += agencyId.computeStringSize(1)
      }
      if hasRouteId {
        serialize_size += routeId.computeStringSize(2)
      }
      if hasRouteType {
        serialize_size += routeType.computeInt32Size(3)
      }
      if hasTrip {
          if let varSizetrip = trip?.computeMessageSize(4) {
              serialize_size += varSizetrip
          }
      }
      if hasStopId {
        serialize_size += stopId.computeStringSize(5)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TransitRealtime.EntitySelector> {
      var mergedArray = Array<TransitRealtime.EntitySelector>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TransitRealtime.EntitySelector? {
      return try TransitRealtime.EntitySelector.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> TransitRealtime.EntitySelector {
      return try TransitRealtime.EntitySelector.Builder().mergeFromData(data, extensionRegistry:TransitRealtime.GtfsRealtimeProtoTxtRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.EntitySelector {
      return try TransitRealtime.EntitySelector.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> TransitRealtime.EntitySelector {
      return try TransitRealtime.EntitySelector.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.EntitySelector {
      return try TransitRealtime.EntitySelector.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.EntitySelector {
      return try TransitRealtime.EntitySelector.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.EntitySelector {
      return try TransitRealtime.EntitySelector.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> TransitRealtime.EntitySelector.Builder {
      return TransitRealtime.EntitySelector.classBuilder() as! TransitRealtime.EntitySelector.Builder
    }
    public func getBuilder() -> TransitRealtime.EntitySelector.Builder {
      return classBuilder() as! TransitRealtime.EntitySelector.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return TransitRealtime.EntitySelector.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return TransitRealtime.EntitySelector.Builder()
    }
    public func toBuilder() throws -> TransitRealtime.EntitySelector.Builder {
      return try TransitRealtime.EntitySelector.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:TransitRealtime.EntitySelector) throws -> TransitRealtime.EntitySelector.Builder {
      return try TransitRealtime.EntitySelector.Builder().mergeFrom(prototype)
    }
    override public func getDescription(indent:String) throws -> String {
      var output:String = ""
      if hasAgencyId {
        output += "\(indent) agencyId: \(agencyId) \n"
      }
      if hasRouteId {
        output += "\(indent) routeId: \(routeId) \n"
      }
      if hasRouteType {
        output += "\(indent) routeType: \(routeType) \n"
      }
      if hasTrip {
        output += "\(indent) trip {\n"
        if let outDescTrip = trip {
          output += try outDescTrip.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasStopId {
        output += "\(indent) stopId: \(stopId) \n"
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(2000), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasAgencyId {
               hashCode = (hashCode &* 31) &+ agencyId.hashValue
            }
            if hasRouteId {
               hashCode = (hashCode &* 31) &+ routeId.hashValue
            }
            if hasRouteType {
               hashCode = (hashCode &* 31) &+ routeType.hashValue
            }
            if hasTrip {
                if let hashValuetrip = trip?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuetrip
                }
            }
            if hasStopId {
               hashCode = (hashCode &* 31) &+ stopId.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(2000)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "TransitRealtime.EntitySelector"
    }
    override public func className() -> String {
        return "TransitRealtime.EntitySelector"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return TransitRealtime.EntitySelector.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:TransitRealtime.EntitySelector = TransitRealtime.EntitySelector()
      public func getMessage() -> TransitRealtime.EntitySelector {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasAgencyId:Bool {
           get {
                return builderResult.hasAgencyId
           }
      }
      public var agencyId:String {
           get {
                return builderResult.agencyId
           }
           set (value) {
               builderResult.hasAgencyId = true
               builderResult.agencyId = value
           }
      }
      public func setAgencyId(value:String) -> TransitRealtime.EntitySelector.Builder {
        self.agencyId = value
        return self
      }
      public func clearAgencyId() -> TransitRealtime.EntitySelector.Builder{
           builderResult.hasAgencyId = false
           builderResult.agencyId = ""
           return self
      }
      public var hasRouteId:Bool {
           get {
                return builderResult.hasRouteId
           }
      }
      public var routeId:String {
           get {
                return builderResult.routeId
           }
           set (value) {
               builderResult.hasRouteId = true
               builderResult.routeId = value
           }
      }
      public func setRouteId(value:String) -> TransitRealtime.EntitySelector.Builder {
        self.routeId = value
        return self
      }
      public func clearRouteId() -> TransitRealtime.EntitySelector.Builder{
           builderResult.hasRouteId = false
           builderResult.routeId = ""
           return self
      }
      public var hasRouteType:Bool {
           get {
                return builderResult.hasRouteType
           }
      }
      public var routeType:Int32 {
           get {
                return builderResult.routeType
           }
           set (value) {
               builderResult.hasRouteType = true
               builderResult.routeType = value
           }
      }
      public func setRouteType(value:Int32) -> TransitRealtime.EntitySelector.Builder {
        self.routeType = value
        return self
      }
      public func clearRouteType() -> TransitRealtime.EntitySelector.Builder{
           builderResult.hasRouteType = false
           builderResult.routeType = Int32(0)
           return self
      }
      public var hasTrip:Bool {
           get {
               return builderResult.hasTrip
           }
      }
      public var trip:TransitRealtime.TripDescriptor! {
           get {
               if tripBuilder_ != nil {
                  builderResult.trip = tripBuilder_.getMessage()
               }
               return builderResult.trip
           }
           set (value) {
               builderResult.hasTrip = true
               builderResult.trip = value
           }
      }
      private var tripBuilder_:TransitRealtime.TripDescriptor.Builder! {
           didSet {
              builderResult.hasTrip = true
           }
      }
      public func getTripBuilder() -> TransitRealtime.TripDescriptor.Builder {
        if tripBuilder_ == nil {
           tripBuilder_ = TransitRealtime.TripDescriptor.Builder()
           builderResult.trip = tripBuilder_.getMessage()
           if trip != nil {
              try! tripBuilder_.mergeFrom(trip)
           }
        }
        return tripBuilder_
      }
      public func setTrip(value:TransitRealtime.TripDescriptor!) -> TransitRealtime.EntitySelector.Builder {
        self.trip = value
        return self
      }
      public func mergeTrip(value:TransitRealtime.TripDescriptor) throws -> TransitRealtime.EntitySelector.Builder {
        if builderResult.hasTrip {
          builderResult.trip = try TransitRealtime.TripDescriptor.builderWithPrototype(builderResult.trip).mergeFrom(value).buildPartial()
        } else {
          builderResult.trip = value
        }
        builderResult.hasTrip = true
        return self
      }
      public func clearTrip() -> TransitRealtime.EntitySelector.Builder {
        tripBuilder_ = nil
        builderResult.hasTrip = false
        builderResult.trip = nil
        return self
      }
      public var hasStopId:Bool {
           get {
                return builderResult.hasStopId
           }
      }
      public var stopId:String {
           get {
                return builderResult.stopId
           }
           set (value) {
               builderResult.hasStopId = true
               builderResult.stopId = value
           }
      }
      public func setStopId(value:String) -> TransitRealtime.EntitySelector.Builder {
        self.stopId = value
        return self
      }
      public func clearStopId() -> TransitRealtime.EntitySelector.Builder{
           builderResult.hasStopId = false
           builderResult.stopId = ""
           return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> TransitRealtime.EntitySelector.Builder {
        builderResult = TransitRealtime.EntitySelector()
        return self
      }
      public override func clone() throws -> TransitRealtime.EntitySelector.Builder {
        return try TransitRealtime.EntitySelector.builderWithPrototype(builderResult)
      }
      public override func build() throws -> TransitRealtime.EntitySelector {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> TransitRealtime.EntitySelector {
        let returnMe:TransitRealtime.EntitySelector = builderResult
        return returnMe
      }
      public func mergeFrom(other:TransitRealtime.EntitySelector) throws -> TransitRealtime.EntitySelector.Builder {
        if other == TransitRealtime.EntitySelector() {
         return self
        }
        if other.hasAgencyId {
             agencyId = other.agencyId
        }
        if other.hasRouteId {
             routeId = other.routeId
        }
        if other.hasRouteType {
             routeType = other.routeType
        }
        if (other.hasTrip) {
            try mergeTrip(other.trip)
        }
        if other.hasStopId {
             stopId = other.stopId
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.EntitySelector.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.EntitySelector.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            agencyId = try input.readString()

          case 18 :
            routeId = try input.readString()

          case 24 :
            routeType = try input.readInt32()

          case 34 :
            let subBuilder:TransitRealtime.TripDescriptor.Builder = TransitRealtime.TripDescriptor.Builder()
            if hasTrip {
              try subBuilder.mergeFrom(trip)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            trip = subBuilder.buildPartial()

          case 42 :
            stopId = try input.readString()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  // An internationalized message containing per-language versions of a snippet of
  // text or a URL.
  // One of the strings from a message will be picked up. The resolution proceeds
  // as follows:
  // 1. If the UI language matches the language code of a translation,
  //    the first matching translation is picked.
  // 2. If a default UI language (e.g., English) matches the language code of a
  //    translation, the first matching translation is picked.
  // 3. If some translation has an unspecified language code, that translation is
  //    picked.
  final public class TranslatedString : ExtendableMessage, GeneratedMessageProtocol{


    //Nested type declaration start

      final public class Translation : ExtendableMessage, GeneratedMessageProtocol{
        // A UTF-8 string containing the message.
        public private(set) var text:String = ""

        public private(set) var hasText:Bool = false
        // BCP-47 language code. Can be omitted if the language is unknown or if
        // no i18n is done at all for the feed. At most one translation is
        // allowed to have an unspecified language tag.
        public private(set) var language:String = ""

        public private(set) var hasLanguage:Bool = false
        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
          if !hasText {
            return false
          }
          if !extensionsAreInitialized() {
           return false
          }
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasText {
            try output.writeString(1, value:text)
          }
          if hasLanguage {
            try output.writeString(2, value:language)
          }
          try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(2000))
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasText {
            serialize_size += text.computeStringSize(1)
          }
          if hasLanguage {
            serialize_size += language.computeStringSize(2)
          }
          serialize_size += extensionsSerializedSize()
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TransitRealtime.TranslatedString.Translation> {
          var mergedArray = Array<TransitRealtime.TranslatedString.Translation>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TransitRealtime.TranslatedString.Translation? {
          return try TransitRealtime.TranslatedString.Translation.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(data:NSData) throws -> TransitRealtime.TranslatedString.Translation {
          return try TransitRealtime.TranslatedString.Translation.Builder().mergeFromData(data, extensionRegistry:TransitRealtime.GtfsRealtimeProtoTxtRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TranslatedString.Translation {
          return try TransitRealtime.TranslatedString.Translation.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) throws -> TransitRealtime.TranslatedString.Translation {
          return try TransitRealtime.TranslatedString.Translation.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TranslatedString.Translation {
          return try TransitRealtime.TranslatedString.Translation.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.TranslatedString.Translation {
          return try TransitRealtime.TranslatedString.Translation.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TranslatedString.Translation {
          return try TransitRealtime.TranslatedString.Translation.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> TransitRealtime.TranslatedString.Translation.Builder {
          return TransitRealtime.TranslatedString.Translation.classBuilder() as! TransitRealtime.TranslatedString.Translation.Builder
        }
        public func getBuilder() -> TransitRealtime.TranslatedString.Translation.Builder {
          return classBuilder() as! TransitRealtime.TranslatedString.Translation.Builder
        }
        public override class func classBuilder() -> MessageBuilder {
          return TransitRealtime.TranslatedString.Translation.Builder()
        }
        public override func classBuilder() -> MessageBuilder {
          return TransitRealtime.TranslatedString.Translation.Builder()
        }
        public func toBuilder() throws -> TransitRealtime.TranslatedString.Translation.Builder {
          return try TransitRealtime.TranslatedString.Translation.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:TransitRealtime.TranslatedString.Translation) throws -> TransitRealtime.TranslatedString.Translation.Builder {
          return try TransitRealtime.TranslatedString.Translation.Builder().mergeFrom(prototype)
        }
        override public func getDescription(indent:String) throws -> String {
          var output:String = ""
          if hasText {
            output += "\(indent) text: \(text) \n"
          }
          if hasLanguage {
            output += "\(indent) language: \(language) \n"
          }
          output += try getExtensionDescription(Int32(1000), endExclusive:Int32(2000), indent:indent)
          output += unknownFields.getDescription(indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasText {
                   hashCode = (hashCode &* 31) &+ text.hashValue
                }
                if hasLanguage {
                   hashCode = (hashCode &* 31) &+ language.hashValue
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(2000)))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "TransitRealtime.TranslatedString.Translation"
        }
        override public func className() -> String {
            return "TransitRealtime.TranslatedString.Translation"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return TransitRealtime.TranslatedString.Translation.self
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
          private var builderResult:TransitRealtime.TranslatedString.Translation = TransitRealtime.TranslatedString.Translation()
          public func getMessage() -> TransitRealtime.TranslatedString.Translation {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasText:Bool {
               get {
                    return builderResult.hasText
               }
          }
          public var text:String {
               get {
                    return builderResult.text
               }
               set (value) {
                   builderResult.hasText = true
                   builderResult.text = value
               }
          }
          public func setText(value:String) -> TransitRealtime.TranslatedString.Translation.Builder {
            self.text = value
            return self
          }
          public func clearText() -> TransitRealtime.TranslatedString.Translation.Builder{
               builderResult.hasText = false
               builderResult.text = ""
               return self
          }
          public var hasLanguage:Bool {
               get {
                    return builderResult.hasLanguage
               }
          }
          public var language:String {
               get {
                    return builderResult.language
               }
               set (value) {
                   builderResult.hasLanguage = true
                   builderResult.language = value
               }
          }
          public func setLanguage(value:String) -> TransitRealtime.TranslatedString.Translation.Builder {
            self.language = value
            return self
          }
          public func clearLanguage() -> TransitRealtime.TranslatedString.Translation.Builder{
               builderResult.hasLanguage = false
               builderResult.language = ""
               return self
          }
          override public var internalGetResult:ExtendableMessage {
               get {
                   return builderResult
               }
          }
          public override func clear() -> TransitRealtime.TranslatedString.Translation.Builder {
            builderResult = TransitRealtime.TranslatedString.Translation()
            return self
          }
          public override func clone() throws -> TransitRealtime.TranslatedString.Translation.Builder {
            return try TransitRealtime.TranslatedString.Translation.builderWithPrototype(builderResult)
          }
          public override func build() throws -> TransitRealtime.TranslatedString.Translation {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> TransitRealtime.TranslatedString.Translation {
            let returnMe:TransitRealtime.TranslatedString.Translation = builderResult
            return returnMe
          }
          public func mergeFrom(other:TransitRealtime.TranslatedString.Translation) throws -> TransitRealtime.TranslatedString.Translation.Builder {
            if other == TransitRealtime.TranslatedString.Translation() {
             return self
            }
            if other.hasText {
                 text = other.text
            }
            if other.hasLanguage {
                 language = other.language
            }
            try mergeExtensionFields(other)
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.TranslatedString.Translation.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TranslatedString.Translation.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let protobufTag = try input.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10 :
                text = try input.readString()

              case 18 :
                language = try input.readString()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end

    public private(set) var translation:Array<TransitRealtime.TranslatedString.Translation>  = Array<TransitRealtime.TranslatedString.Translation>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInittranslation:Bool = true
      for oneElementtranslation in translation {
          if (!oneElementtranslation.isInitialized()) {
              isInittranslation = false
              break 
          }
      }
      if !isInittranslation {
       return isInittranslation
       }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      for oneElementtranslation in translation {
          try output.writeMessage(1, value:oneElementtranslation)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(2000))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementtranslation in translation {
          serialize_size += oneElementtranslation.computeMessageSize(1)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TransitRealtime.TranslatedString> {
      var mergedArray = Array<TransitRealtime.TranslatedString>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TransitRealtime.TranslatedString? {
      return try TransitRealtime.TranslatedString.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> TransitRealtime.TranslatedString {
      return try TransitRealtime.TranslatedString.Builder().mergeFromData(data, extensionRegistry:TransitRealtime.GtfsRealtimeProtoTxtRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TranslatedString {
      return try TransitRealtime.TranslatedString.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> TransitRealtime.TranslatedString {
      return try TransitRealtime.TranslatedString.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TranslatedString {
      return try TransitRealtime.TranslatedString.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.TranslatedString {
      return try TransitRealtime.TranslatedString.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TranslatedString {
      return try TransitRealtime.TranslatedString.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> TransitRealtime.TranslatedString.Builder {
      return TransitRealtime.TranslatedString.classBuilder() as! TransitRealtime.TranslatedString.Builder
    }
    public func getBuilder() -> TransitRealtime.TranslatedString.Builder {
      return classBuilder() as! TransitRealtime.TranslatedString.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return TransitRealtime.TranslatedString.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return TransitRealtime.TranslatedString.Builder()
    }
    public func toBuilder() throws -> TransitRealtime.TranslatedString.Builder {
      return try TransitRealtime.TranslatedString.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:TransitRealtime.TranslatedString) throws -> TransitRealtime.TranslatedString.Builder {
      return try TransitRealtime.TranslatedString.Builder().mergeFrom(prototype)
    }
    override public func getDescription(indent:String) throws -> String {
      var output:String = ""
      var translationElementIndex:Int = 0
      for oneElementtranslation in translation {
          output += "\(indent) translation[\(translationElementIndex)] {\n"
          output += try oneElementtranslation.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          translationElementIndex += 1
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(2000), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementtranslation in translation {
                hashCode = (hashCode &* 31) &+ oneElementtranslation.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(2000)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "TransitRealtime.TranslatedString"
    }
    override public func className() -> String {
        return "TransitRealtime.TranslatedString"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return TransitRealtime.TranslatedString.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:TransitRealtime.TranslatedString = TransitRealtime.TranslatedString()
      public func getMessage() -> TransitRealtime.TranslatedString {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var translation:Array<TransitRealtime.TranslatedString.Translation> {
           get {
               return builderResult.translation
           }
           set (value) {
               builderResult.translation = value
           }
      }
      public func setTranslation(value:Array<TransitRealtime.TranslatedString.Translation>) -> TransitRealtime.TranslatedString.Builder {
        self.translation = value
        return self
      }
      public func clearTranslation() -> TransitRealtime.TranslatedString.Builder {
        builderResult.translation.removeAll(keepCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> TransitRealtime.TranslatedString.Builder {
        builderResult = TransitRealtime.TranslatedString()
        return self
      }
      public override func clone() throws -> TransitRealtime.TranslatedString.Builder {
        return try TransitRealtime.TranslatedString.builderWithPrototype(builderResult)
      }
      public override func build() throws -> TransitRealtime.TranslatedString {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> TransitRealtime.TranslatedString {
        let returnMe:TransitRealtime.TranslatedString = builderResult
        return returnMe
      }
      public func mergeFrom(other:TransitRealtime.TranslatedString) throws -> TransitRealtime.TranslatedString.Builder {
        if other == TransitRealtime.TranslatedString() {
         return self
        }
        if !other.translation.isEmpty  {
           builderResult.translation += other.translation
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TransitRealtime.TranslatedString.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TranslatedString.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            let subBuilder = TransitRealtime.TranslatedString.Translation.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            translation += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

}

// @@protoc_insertion_point(global_scope)
